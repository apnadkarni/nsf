# -*- Tcl -*-
package require nx
#package require nx::plain-object-method

::nx::configure defaultMethodCallProtection false
package require nx::test

nx::Test parameter count 10

nx::Class create C {
  # methods
  :method plain_method {} {return [current method]}
  :public method public_method {} {return [current method]}
  :protected method protected_method {} {return [current method]}

  # forwards
  :forward plain_forward %self plain_method
  :public forward public_forward %self public_method
  :protected forward protected_forward %self protected_method

  # setter
  :property plain_setter 
  :property -accessor public public_setter 
  :property -accessor protected protected_setter 

  # alias
  :alias plain_alias [C info method registrationhandle plain_method]
  :public alias public_alias [C info method registrationhandle public_method]
  :protected alias protected_alias [C info method registrationhandle protected_method]
  
  # class-object
  :object method plain_object_method {} {return [current method]}
  :public object method public_object_method {} {return [current method]}
  :protected object method protected_object_method {}  {return [current method]}
  :object forward plain_object_forward %self plain_object_method
  :public object forward public_object_forward %self public_object_method
  :protected object forward protected_object_forward %self protected_object_method

  :object property {plain_object_setter ""}
  :object property -accessor public {public_object_setter ""}
  :object property -accessor protected {protected_object_setter ""}

  :object alias plain_object_alias [:info object method registrationhandle plain_object_method]
  :public object alias public_object_alias [:info object method registrationhandle public_object_method]
  :protected object alias protected_object_alias [:info object method registrationhandle protected_object_method]
}
C create c1 {
  # methods
  :object method plain_object_method {} {return [current method]}
  :public object method public_object_method {} {return [current method]}
  :protected object method protected_object_method {} {return [current method]}

  # forwards
  :object forward plain_object_forward %self plain_object_method
  :public object forward public_object_forward %self public_object_method
  :protected object forward protected_object_forward %self protected_object_method

  # setter
  :object property {plain_object_setter ""}
  :object property -accessor public {public_object_setter ""}
  :object property -accessor protected protected_object_setter 

  # alias
  :object alias plain_object_alias [:info object method registrationhandle plain_object_method]
  :public object alias public_object_alias [:info object method registrationhandle public_object_method]
  :protected object alias protected_object_alias [:info object method registrationhandle protected_object_method]
}
C property -accessor public s0
C property -accessor protected s1
? {c1 s0 0} 0
? {::nsf::dispatch c1 s1 1} 1
C object property -accessor public {s3 ""}
? {C s3 3} 3

# create a fresh object (different from c1)
C create c2
# test scripted class level methods
nx::Test case scripted-class-level-methods {
  ? {c2 plain_method} "plain_method"
  ? {c2 public_method} "public_method"
  ? {catch {c2 protected_method}} 1
  ? {::nsf::dispatch c2 protected_method} "protected_method"
}

# class level forwards
nx::Test case class-level-forwards {
  ? {c2 plain_forward} "plain_method"
  ? {c2 public_forward} "public_method"
  ? {catch {c2 protected_forward}} 1
  ? {::nsf::dispatch c2 protected_forward} "protected_method"
}

# class level setter
nx::Test case class-level-setter {
  #? {c2 plain_setter 1} {::c2: unable to dispatch method 'plain_setter'}
  ? {c2 plain_setter 1} 1
  ? {c2 public_setter 2} "2"
  ? {catch {c2 protected_setter 3}} 1
  ? {::nsf::dispatch c2 protected_setter 4} "4"
}

# class level alias ....
nx::Test case class-level-alias {
  ? {c2 plain_alias} "plain_alias"
  ? {c2 public_alias} "public_alias"
  ? {catch {c2 protected_alias}} 1
  ? {::nsf::dispatch c2 protected_alias} "protected_alias"
}

###########

# scripted class level methods
nx::Test case scripted-class-object-level {
  ? {C plain_object_method} "plain_object_method"
  ? {C public_object_method} "public_object_method"
  ? {catch {C protected_object_method}} 1
  ? {::nsf::dispatch C protected_object_method} "protected_object_method"
}

# class level forwards
nx::Test case class-object-level-forwards {
  ? {C plain_object_forward} "plain_object_method"
  ? {C public_object_forward} "public_object_method"
  ? {catch {C protected_object_forward}} 1
  ? {::nsf::dispatch C protected_object_forward} "protected_object_method"
}

# class level setter
nx::Test case class-object-level-setter {
  #? {C plain_object_setter 1} {method 'plain_object_setter' unknown for ::C; consider '::C create plain_object_setter 1' instead of '::C plain_object_setter 1'}
  ? {C plain_object_setter 1} "1"
  ? {C public_object_setter 2} "2"
  ? {catch {C protected_object_setter 3}} 1
  ? {::nsf::dispatch C protected_object_setter 4} "4"
}

# class level alias ....
nx::Test case class-object-level-alias {
  ? {C plain_object_alias} "plain_object_alias"
  ? {C public_object_alias} "public_object_alias"
  ? {catch {C protected_object_alias}} 1
  ? {::nsf::dispatch C protected_object_alias} "protected_object_alias"
}

###########

# scripted object level methods
nx::Test case scripted-object-level-methods {
  ? {c1 plain_object_method} "plain_object_method"
  ? {c1 public_object_method} "public_object_method"
  ? {catch {c1 protected_object_method}} 1
  ? {::nsf::dispatch c1 protected_object_method} "protected_object_method"
}

# object level forwards
nx::Test case object-level-forwards {
  ? {c1 plain_object_forward} "plain_object_method"
  ? {c1 public_object_forward} "public_object_method"
  ? {catch {c1 protected_object_forward}} 1
  ? {::nsf::dispatch c1 protected_object_forward} "protected_object_method"
}

# object level setter
nx::Test case object-level-setter {
  #? {c1 plain_object_setter 1} {::c1: unable to dispatch method 'plain_object_setter'}
  ? {c1 plain_object_setter 1} "1"
  ? {c1 public_object_setter 2} "2"
  ? {catch {c1 protected_object_setter 3}} 1
  ? {::nsf::dispatch c1 protected_object_setter 4} "4"
}

# object level alias ....
nx::Test case object-level-alias {
  ? {c1 plain_object_alias} "plain_object_alias"
  ? {c1 public_object_alias} "public_object_alias"
  ? {catch {c1 protected_object_alias}} 1
  ? {::nsf::dispatch c1 protected_object_alias} "protected_object_alias"

  #? {lsort [c1 info object methods]} \
      "plain_object_alias plain_object_forward plain_object_method public_object_alias public_object_forward public_object_method public_object_setter"
  ? {lsort [c1 info object methods]} \
      "plain_object_alias plain_object_forward plain_object_method plain_object_setter public_object_alias public_object_forward public_object_method public_object_setter"

  #? {lsort [C info methods]} \
      "plain_object_alias plain_object_forward plain_object_method public_object_alias public_object_forward public_object_method public_object_setter s3"
  ? {lsort [C info object methods]} \
      "plain_object_alias plain_object_forward plain_object_method plain_object_setter public_object_alias public_object_forward public_object_method public_object_setter s3"
}

C destroy

nx::Test case colondispatch {
  nx::Object create ::o {
    #:public object method foo args {;}
    :public object method bar args {;}
  }
  ? {o :bar} "::o: method name ':bar' must not start with a colon" 
  ? {o eval :bar} "" 
  ? {o :foo} "::o: method name ':foo' must not start with a colon" 
  ? {o eval :foo} "::o: unable to dispatch method 'foo'" 
}

nx::Test case mixinguards {
  # define a Class C and mixin class M
  nx::Class create C
  nx::Class create M

  # register the mixin on C as a object mixin and define a mixinguard
  C mixin M
  C mixin guard M {1 == 1}
  ? {C info mixin guard M} "1 == 1"
  C mixin guard M {}
  ? {C info mixin guard M} ""

  # now the same as class mixin and class mixin guard
  C object mixin M
  C object mixin guard M {1 == 1}
  ? {C info object mixin guard M} "1 == 1"
  C object mixin guard M {}
  ? {C info object mixin guard M} ""
}

nx::Test case mixin-via-objectparam {
  # add an object and class mixin via object-parameter and via slots
  nx::Class create M1; nx::Class create M2; nx::Class create M3; nx::Class create M4
  nx::Class create C -mixin M1 -object-mixin M2 {
    :mixin add M3
    :object mixin add M4
  }
  
  ? {lsort [C info object mixin classes]} "::M2 ::M4"
  #? {lsort [C info object mixin classes]} "::M2"

  ? {lsort [C info mixin classes]} "::M1 ::M3"
  #? {lsort [C info mixin classes]} "::M1"
  C destroy
  M1 destroy; M2 destroy; M3 destroy; M4 destroy;
}

# testing next via nonpos-args
nx::Test case next-from-nonpos-args {
  
  nx::Object create o {
    :object method bar {-y:required -x:required} {
      #puts stderr "+++ o x=$x, y=$y [current args] ... next [current nextmethod]"
      return [list x $x y $y [current args]]
    }
  }
  nx::Class create M {
    :method bar {-x:required -y:required} {
      #puts stderr "+++ M x=$x, y=$y [current args] ... next [current nextmethod]"
      return [list x $x y $y [current args] -- {*}[next]]
    }
  }
  
  o object mixin M
  ? {o bar -x 13 -y 14} "x 13 y 14 {-x 13 -y 14} -- x 13 y 14 {-x 13 -y 14}"
  ? {o bar -y 14 -x 13} "x 13 y 14 {-y 14 -x 13} -- x 13 y 14 {-y 14 -x 13}"
}

# 
# test method property with protected/public
# 
nx::Test case property-method {

  nx::Class create C {
    set x [:property -accessor public a]

    ? [list set _ $x] "::nsf::classes::C::a"

    # property with default
    :property {b b1}
    :property -accessor public {c c1}
    :property -accessor protected {d d1}

    set X [:object property -accessor public A]
    ? [list set _ $X] "::C::A"
    
    # object property with default
    :object property {B B2}
    :object property -accessor public {C C2}
    :object property -accessor protected {D D2}
  }

  C create c1 -a 1
  ? {c1 a} 1
  ? {c1 cget -b} b1
  ? {c1 cget -c} c1
  ? {c1 d} "::c1: unable to dispatch method 'd'"

  ? {C A 2} 2
  ? {C A} 2
  #? {C B} {method 'B' unknown for ::C; consider '::C create B ' instead of '::C B '}
  ? {C B} B2
  ? {C C} C2
  ? {C D} "method 'D' unknown for ::C; consider '::C create D ' instead of '::C D '"

  nx::Object create o {
    set x [:object property -accessor public a]
    ? [list set _ $x] "::o::a"

    # property with default
    :object property {b b1}
    :object property -accessor public {c c1}
    :object property -accessor protected {d d1}
  }
  ? {o a 2} 2
  #? {o b} {::o: unable to dispatch method 'b'}
  ? {o b} b1
  ? {o c} c1
  ? {o d} "::o: unable to dispatch method 'd'"
}

nx::Test case subcmd {
  
  nx::Class create Foo {

     :method "Info filter guard" {filter} {return [current object]-[current method]}
     :method "Info filter methods" {-guards pattern:optional} {return [current object]-[current method]}
     :method "Info args" {} {return [current object]-[current method]}
     :method "Info foo" {} {return [current object]-[current method]}

     :object method "INFO filter guard" {a b} {return [current object]-[current method]}
     :object method "INFO filter methods" {-guards pattern:optional} {return [current object]-[current method]}
   }
  
  ? {Foo INFO filter guard 1 2} ::Foo-guard
  ? {Foo INFO filter methods a*} ::Foo-methods
  
  Foo create f1 {
    :object method "list length" {} {return [current object]-[current method]}
    :object method "list reverse" {} {return [current object]-[current method]}
  }

  ? {f1 Info filter guard x} "::f1-guard"
  ? {f1 Info filter methods} "::f1-methods"
  ? {f1 Info args} "::f1-args"
  ? {f1 Info foo} "::f1-foo"

  ? {f1 list length} "::f1-length"
  ? {f1 list reverse} "::f1-reverse"
}

package req nx::serializer
nx::Test case class-object-property {
  nx::Class create C {
    :object property -accessor public x
    :property -accessor public a:int
    :create c1
  }
  ? {C x 1} 1
  ? {C x} 1
  ? {lsort [C info methods]} "a"
  ? {lsort [C info object methods]} "x"
  ? {c1 a b} {expected integer but got "b" for parameter "a"}

  set s(C) [C serialize]
  set s(c1) [c1 serialize]

  # Destroy object and class
  c1 destroy
  C destroy

  ? {nsf::object::exists c1} 0
  ? {nsf::object::exists C} 0

  # create it from the serialized code
  eval $s(C)
  ? {nsf::object::exists C} 1
  eval $s(c1)
  ? {nsf::object::exists c1} 1

  # tests should work as again
  ? {C x} 1
  ? {lsort [C info methods]} "a"
  ? {lsort [C info object methods]} "x"
  ? {c1 a b} {expected integer but got "b" for parameter "a"}  
}

#
# Test method deletion
#
nx::Test parameter count 1

nx::Test case methoddelete {
  nx::Class create C {
    :public method foo {x} {return $x}
    :public object method bar {x} {return $x}
    :create c1
  }
  
  ? {::nsf::method::delete C x} "::C: instance method 'x' does not exist"
  ? {::nsf::method::delete C -per-object x} "::C: object specific method 'x' does not exist"
  ? {::nsf::method::delete C foo} ""
  ? {::nsf::method::delete C foo} "::C: instance method 'foo' does not exist"
  ? {::nsf::method::delete C bar} "::C: instance method 'bar' does not exist"
  ? {::nsf::method::delete C -per-object bar} ""
  ? {::nsf::method::delete C -per-object bar} "::C: object specific method 'bar' does not exist"
}

#
# Test error message of method modifier
#
nx::Test parameter count 1

nx::Test case errormessage {
  nx::Class create C
  ? {C public method foo {x} {return $x}} "::nsf::classes::C::foo"
  ? {C public Object method bar {x} {return $x}} \
      "'Object' is not a method defining method"
  ? {C protected Object method bar {x} {return $x}} \
      "'Object' is not a method defining method"
  ? {C Object method bar {x} {return $x}} \
      {method 'Object' unknown for ::C; consider '::C create Object method bar x {return $x}' instead of '::C Object method bar x {return $x}'}
  #? {C public object Object method bar {x} {return $x}} "'Object' not allowed to be modified by 'class'"
  #? {C public object Object method bar {x} {return $x}} \
      {'Object' is not a method defining method}
}

#
# test dispatch without object
#
nx::Test case dispatch-without-object {

  nx::Object create o {
    # property defines a setter, we need a current object
    :object property -accessor public {a v}
    # the other methods don't require them as strong
    :object forward b ::o2 bar
    :object method foo {} {return [nx::self]}
    :object alias x ::o::foo
  }
  nx::Object create o2 {
    :public object method bar {} {return [nx::self]}
  }

  # dispatch methods without current object 
  ? ::o::a "method ::o::a not dispatched on valid object"
  ? ::o::b "::o2"
  ? ::o::foo "no current object; command called outside the context of a Next Scripting method"
  ? ::o::x "no current object; x called outside the context of a Next Scripting method"
  # make a regular call, provide tcd->object with a value
  ? {::o x} "::o"
  # check, if missing object is still detected
  ? ::o::x "no current object; x called outside the context of a Next Scripting method"
  ? nx::self "no current object; command called outside the context of a Next Scripting method"
}


#
# Test the current namespaces and resolution for
# a) top-level methods
# b) ensemble methods on level 1
# c) ensemble methods on level 2
#
nx::Test case scopes {
  nx::Object create o1 {
    :public object method foo {} {return [namespace current]-[namespace which info]}
    :public object method "info foo" {} {return [namespace current]-[namespace which info]}
    :public object method "info bar foo" {} {return [namespace current]-[namespace which info]}
  }

  ? {o1 foo} "::-::info"
  ? {o1 info foo} "::-::info"
  ? {o1 info bar foo} "::-::info"

  nx::Class create C {
    :public method foo {} {return [namespace current]-[namespace which info]}
    :public method "info foo" {} {return [namespace current]-[namespace which info]}
    :public method "info bar foo" {} {return [namespace current]-[namespace which info]}
    :create c1
  }

  ? {c1 foo} "::-::info"
  ? {c1 info foo} "::-::info"
  ? {c1 info bar foo} "::-::info"
}

#
# Test the current namespaces and resolution for methods
# registered on a object in a certain namespace
# a) top-level methods
# b) ensemble methods on level 1
# c) ensemble methods on level 2
#
nx::Test case namespaced-scopes {

  namespace eval ::ns {
    nx::Object create o1 {
      :public object method foo {} {return [namespace current]-[namespace which info]}
      :public object method "info foo" {} {return [namespace current]-[namespace which info]}
      :public object method "info bar foo" {} {return [namespace current]-[namespace which info]}
    }
    nx::Class create C {
      :public method foo {} {return [namespace current]-[namespace which info]}
      :public method "info foo" {} {return [namespace current]-[namespace which info]}
      :public method "info bar foo" {} {return [namespace current]-[namespace which info]}
      :create c1
    }
  }

  ? {ns::o1 foo} "::ns-::info"
  ? {ns::o1 info foo} "::ns-::info"
  ? {ns::o1 info bar foo} "::ns-::info"

  ? {ns::c1 foo} "::ns-::info"
  ? {ns::c1 info foo} "::ns-::info"
  ? {ns::c1 info bar foo} "::ns-::info"
}


#
# Test the current namespaces and resolution for methods
# registered on a sub object
# a) top-level methods
# b) ensemble methods on level 1
# c) ensemble methods on level 2
#
nx::Test case nested-scopes {
  nx::Object create o 
  nx::Object create o::o1 {
    :public object method foo {} {return [namespace current]-[namespace which info]}
    :public object method "info foo" {} {return [namespace current]-[namespace which info]}
    :public object method "info bar foo" {} {return [namespace current]-[namespace which info]}
  }

  ? {o::o1 foo} "::o-::info"
  ? {o::o1 info foo} "::o-::info"
  ? {o::o1 info bar foo} "::o-::info"

  nx::Class create o::C {
    :public method foo {} {return [namespace current]-[namespace which info]}
    :public method "info foo" {} {return [namespace current]-[namespace which info]}
    :public method "info bar foo" {} {return [namespace current]-[namespace which info]}
    :create c1
  }

  ? {c1 foo} "::o-::info"
  ? {c1 info foo} "::o-::info"
  ? {c1 info bar foo} "::o-::info"
}

#
# Test deletion of object-specific methods/attributes via "delete
# method" and "delete property"
#
# a) test attributes
# b) test simple methods
# c) test ensemble methods
#
nx::Test case delete-per-object {
  nx::Object create o1 {
    :object property -accessor public a1 
    :object property -accessor public a2
    :public object method foo {} {return [namespace current]-[namespace which info]}
    :public object method "info foo" {} {return [namespace current]-[namespace which info]}
    :public object method "info bar foo" {} {return [namespace current]-[namespace which info]}
  }

  ? {o1 info object methods -path} "{info foo} {info bar foo} foo a1 a2"
  ? {o1 info children} "::o1::info ::o1::per-object-slot"

  ? {o1 delete method bar} "::o1: object specific method 'bar' does not exist"
  # For a1, we have a method and an property. We can delete the
  # method without the slot.
  ? {o1 delete method a1} ""
  # After the deletion of the accessor, the slot exists still
  ? {o1::per-object-slot info children} "::o1::per-object-slot::a1 ::o1::per-object-slot::a2"
  # If we perform now a "delete property a1", the slot will be removed.
  ? {o1 delete property a1} ""
  ? {o1::per-object-slot info children} "::o1::per-object-slot::a2"

  # try to delete the property again:
  ? {o1 delete property a1} "::o1: cannot delete object specific property 'a1'"

  ? {o1 info object methods -path} "{info foo} {info bar foo} foo a2"
  ? {o1 delete property a2} ""
  ? {o1 info object methods -path} "{info foo} {info bar foo} foo"

  ? {o1 delete method foo} ""
  ? {o1 info object methods -path} "{info foo} {info bar foo}"

  ? {o1 delete method "info foo"} ""
  ? {o1 info object methods -path} "{info bar foo}"

  ? {o1 delete method "info bar foo"} ""
  ? {o1 info object methods -path} ""
}

#
# Test deletion of per-object methods/attributes defined on classes
# via the delete method
# a) test attributes
# b) test simple methods
# c) test ensemble methods
#
nx::Test case delete-per-object-on-class {
  nx::Class create C {
    :object property -accessor public a1
    :public object method foo {} {return [namespace current]-[namespace which info]}
    :public object method "info foo" {} {return [namespace current]-[namespace which info]}
    :public object method "info bar foo" {} {return [namespace current]-[namespace which info]}
    :property -accessor public a2
  }

  ? {C info object methods -path} "{info foo} {info bar foo} foo a1"
  ? {C info children} "::C::info ::C::slot ::C::per-object-slot"

  ? {C delete object method bar} "::C: object specific method 'bar' does not exist"

  ? {C delete object property a1} ""
  ? {C info object methods -path} "{info foo} {info bar foo} foo"
  ? {C delete object property a1} "::C: cannot delete object specific property 'a1'"

  ? {C delete object method foo} ""
  ? {C info object methods -path} "{info foo} {info bar foo}"

  ? {C delete object method "info foo"} ""
  ? {C info object methods -path} "{info bar foo}"

  ? {C delete object method "info bar foo"} ""
  ? {C info object methods -path} ""

  ? {C info methods} "a2"
  ? {C info slot objects} "::C::slot::a2"
}


#
# Test deletion of methods/attributes defined on classes via the
# delete method
# a) test attributes
# b) test simple methods
# c) test ensemble methods
#
nx::Test case delete-class-level-method {
  nx::Class create C {
    :property -accessor public a1
    :public method foo {} {return [namespace current]-[namespace which info]}
    :public method "info foo" {} {return [namespace current]-[namespace which info]}
    :public method "info bar foo" {} {return [namespace current]-[namespace which info]}
  }

  ? {C info methods -path} "{info foo} {info bar foo} foo a1"
  ? {C info children} "::C::slot"

  ? {C delete method bar} "::C: instance method 'bar' does not exist"

  ? {C delete property a1} ""
  ? {C info methods -path} "{info foo} {info bar foo} foo"

  ? {C delete property a1} "::C: cannot delete property 'a1'"

  ? {C delete method foo} ""
  ? {C info methods -path} "{info foo} {info bar foo}"

  ? {C delete method "info foo"} ""
  ? {C info methods -path} "{info bar foo}"

  ? {C delete method "info bar foo"} ""
  ? {C info methods -path} ""
}

#
# simple unknown tests; 
# ensemble unknown tests are in submethods.test
#
nx::Test case test-simple-unknown {

  #
  # calling unknown with a plain "method" without arguments
  #
  ::nx::Class create A {
    :object method unknown args {? [list set _ $args] "hello"}
  }
  A hello

  #
  # calling unknown with a plain "method" with arguments
  #
  ::nx::Class create B {
    :object method unknown args {? [list set _ $args] "hello world"}
  }
  B hello world

  #
  # calling unknown with a method with spaces
  #
  ::nx::Class create C {
    :object method unknown args {? [list set _ $args] "{hello world}"}
  }
  C {hello world}
}


#
# simple speed tests
# ensemble unknown tests are in submethods.test
#
nx::Test parameter count 1000
nx::Test case speed-dispatch {

  #
  # define various forms of simple dispatches
  #
  ::nx::Object create o {
    :public object method foo {} {return ::o}
    :public object method bar00 {} {self}
    :public object method bar01 {} {:}
    :public object method bar02 {} {[self]}
    :public object method bar03 {} {[:]}
    :public object method bar04 {} {:foo}
    :public object method bar05 {} {: foo}
    #:public object method bar06 {} {my foo}
    :public object method bar07 {} {[self] foo}
    :public object method bar08 {} {: -system info object methods foo}
    #:public object method bar09 {} {my -system info object methods foo}
  }

  ? {o foo} ::o
  ? {o bar00} ::o {self}
  ? {o bar01} ::o {:}
  ? {o bar02} ::o {[self]}
  ? {o bar03} ::o {[:]}
  ? {o bar04} ::o ":foo"
  ? {o bar05} ::o ": foo"
  #? {o bar06} ::o "my foo"
  ? {o bar07} ::o "self foo"
  ? {o bar08} foo ": -system info"
  #? {o bar09} foo "my -system info"
}

nx::Test parameter count 1
nx::Test case fq-obj-dispatch {
  #
  # Capture the (current) dispatcher rules for fully-qualified
  # selectors which resolve to existing objects.
  #
  nx::Class create C {
    set :unknown 0
    :public object method unknown {m args} {
      incr :unknown
      return unknown-$m
    }
  }

  nx::Class create D {
    set :defaultcalled 0
    :public method defaultmethod args {
      [current class] eval [list incr :defaultcalled]
    }
    :create ::d
  }
  
  ? {::D eval {set :defaultcalled}} 0
  ? {::d} 1
  ? {C eval {set :unknown}} 0
  ? {C ::d} "unknown-::d"
  ? {C eval {set :unknown}} 1
  ? {::d} 2; # should not be 3!
  ? {C d} "unknown-d"
  ? {C eval {set :unknown}} 2
  ? {::d} 3

  #
  # nested-object selector, *not* pre-existing
  #
  ? {::nsf::object::exists ::d::c} 0
  ? {C ::d::c} "unknown-::d::c"
  ? {C eval {set :unknown}} 3
  ? {::nsf::object::exists ::d::c} 0

  #
  # nested-object selector, pre-existing
  #
  ? {::nsf::object::exists ::d::dd} 0
  D create ::d::dd
  ? {::nsf::object::exists ::d::dd} 1
  ? {::D eval {set :defaultcalled}} 3
  ? {::d::dd} 4
  ? {C eval {set :unknown}} 3
  ? {C ::d::dd} "unknown-::d::dd"
  ? {C eval {set :unknown}} 4
  ? {C d::dd} "unknown-d::dd"
  ? {C eval {set :unknown}} 5
  ? {::D eval {set :defaultcalled}} 4

  #
  # namespaced selector, *not* pre-existing
  #
  namespace eval ::ns1 {}
  ? {::nsf::object::exists ::ns1::c} 0
  ? {C ::ns1::c} "unknown-::ns1::c"
  ? {C eval {set :unknown}} 6
  ? {::nsf::object::exists ::ns1::c} 0

  #
  # namespaced selector, pre-existing
  #
  ? {::nsf::object::exists ::ns1::d} 0
  D create ::ns1::d
  ? {::nsf::object::exists ::ns1::d} 1
  ? {::D eval {set :defaultcalled}} 4
  ? {::ns1::d} 5
  ? {C eval {set :unknown}} 6
  ? {C ::ns1::d} "unknown-::ns1::d"
  ? {C eval {set :unknown}} 7
  ? {C ns1::d} "unknown-ns1::d"
  ? {C eval {set :unknown}} 8
  ? {::D eval {set :defaultcalled}} 5

  #
  # Is XOTcl's creation short-cut operative for nested-object
  # selectors, compliant with the XOTcl-specific unknown-(re)create
  # protocol?
  #
  package req XOTcl 2.0
  
  ? {::nsf::object::exists ::X} 0
  xotcl::Class ::X -instproc p1 {v} {
    [self class] incr [self proc] $v
  } -proc unknown args {
    my incr [self proc]
    next
  } -set unknown 0 -proc recreate args {
    my incr [self proc]
    next
  } -set recreate 0
  
  ? {::nsf::object::exists ::X} 1
  ? {::X exists p1} 0
  ? {::X set unknown} 0

  xotcl::Object ::p
  ? {::nsf::object::exists ::p::child} 0
  ::X ::p::child -p1 2
  ? {::nsf::object::exists ::p::child} 1
  ? {::X set p1} 2
  ? {::X set unknown} 1
  ? {::X set recreate} 0
  ::X ::p::child -p1 1
  ? {::X set p1} 3
  ? {::X set unknown} 2
  ? {::X set recreate} 1
}