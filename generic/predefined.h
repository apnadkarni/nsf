static char cmd[] = 
"\n"
"namespace eval ::next {\n"
"set bootstrap 1\n"
"::next::core::createobjectsystem ::next::Object ::next::Class {\n"
"-class.alloc alloc\n"
"-class.create create\n"
"-class.dealloc dealloc\n"
"-class.recreate recreate\n"
"-class.requireobject __unknown\n"
"-object.configure configure\n"
"-object.defaultmethod defaultmethod\n"
"-object.destroy destroy\n"
"-object.init init\n"
"-object.move move\n"
"-object.objectparameter objectparameter\n"
"-object.residualargs residualargs\n"
"-object.unknown unknown}\n"
"namespace eval ::next::core {\n"
"namespace export next self \\\n"
"my is relation interp}\n"
"namespace import ::next::core::next ::next::core::self\n"
"foreach cmd [info command ::next::core::cmd::Object::*] {\n"
"set cmdName [namespace tail $cmd]\n"
"if {$cmdName in [list \"instvar\"]} continue\n"
"::next::core::alias Object $cmdName $cmd}\n"
"::next::core::alias Object eval -nonleaf ::eval\n"
"foreach cmd [info command ::next::core::cmd::Class::*] {\n"
"set cmdName [namespace tail $cmd]\n"
"::next::core::alias Class $cmdName $cmd}\n"
"foreach cmd [list __next cleanup  noinit residualargs uplevel upvar] {\n"
"::next::core::methodproperty Object $cmd protected 1}\n"
"foreach cmd [list recreate] {\n"
"::next::core::methodproperty Class $cmd protected 1}\n"
"::next::core::methodproperty Object destroy redefine-protected true\n"
"::next::core::methodproperty Class  alloc   redefine-protected true\n"
"::next::core::methodproperty Class  dealloc redefine-protected true\n"
"::next::core::methodproperty Class  create  redefine-protected true\n"
"::next::core::method Class method {\n"
"name arguments body -precondition -postcondition} {\n"
"set conditions [list]\n"
"if {[info exists precondition]}  {lappend conditions -precondition  $precondition}\n"
"if {[info exists postcondition]} {lappend conditions -postcondition $postcondition}\n"
"::next::core::method [::next::core::current object] $name $arguments $body {*}$conditions}\n"
"::next::core::method Object method {\n"
"name arguments body -precondition -postcondition} {\n"
"set conditions [list]\n"
"if {[info exists precondition]}  {lappend conditions -precondition  $precondition}\n"
"if {[info exists postcondition]} {lappend conditions -postcondition $postcondition}\n"
"::next::core::method [::next::core::current object] -per-object $name $arguments $body {*}$conditions}\n"
"Class eval {\n"
":method object {what args} {\n"
"if {$what in [list \"alias\" \"attribute\" \"forward\" \"method\" \"setter\"]} {\n"
"return [::next::core::dispatch [::next::core::current object] ::next::core::classes::next::Object::$what {*}$args]}\n"
"if {$what in [list \"info\"]} {\n"
"return [::next::objectInfo [lindex $args 0] [::next::core::current object] {*}[lrange $args 1 end]]}\n"
"if {$what in [list \"filter\" \"mixin\"]} {\n"
"return [:object-$what {*}$args]}\n"
"if {$what in [list \"filterguard\" \"mixinguard\"]} {\n"
"return [::next::core::dispatch [::next::core::current object] ::next::core::cmd::Object::$what {*}$args]}}\n"
":method unknown {m args} {\n"
"error \"Method '$m' unknown for [::next::core::current object].\\\n"
"Consider '[::next::core::current object] create $m $args' instead of '[::next::core::current object] $m $args'\"}\n"
"::next::core::methodproperty [::next::core::current object] unknown protected 1}\n"
"Object eval {\n"
":method public {args} {\n"
"set p [lsearch -regexp $args {^(method|alias|attribute|forward|setter)$}]\n"
"if {$p == -1} {error \"$args is not a method defining method\"}\n"
"set r [{*}:$args]\n"
"::next::core::methodproperty [::next::core::current object] $r protected false\n"
"return $r}\n"
":method protected {args} {\n"
"set p [lsearch -regexp $args {^(method|alias|attribute|forward|setter)$}]\n"
"if {$p == -1} {error \"$args is not a method defining command\"}\n"
"set r [{*}:$args]\n"
"::next::core::methodproperty [::next::core::current object] $r [::next::core::current method] true\n"
"return $r}\n"
":protected method unknown {m args} {\n"
"if {![::next::core::current isnext]} {\n"
"error \"[::next::core::current object]: unable to dispatch method '$m'\"}}\n"
":protected method init args {}\n"
":protected method defaultmethod {} {::next::core::current object}\n"
":protected method objectparameter {} {;}}\n"
"::next::core::forward Object forward ::next::core::forward %self -per-object\n"
"::next::core::forward Class  forward ::next::core::forward %self\n"
"Class protected object method __unknown {name} {}\n"
"Object public method alias {-nonleaf:switch -objscope:switch methodName cmd} {\n"
"::next::core::alias [::next::core::current object] -per-object $methodName \\\n"
"{*}[expr {${objscope} ? \"-objscope\" : \"\"}] \\\n"
"{*}[expr {${nonleaf} ? \"-nonleaf\" : \"\"}] \\\n"
"$cmd}\n"
"Class public method alias {-nonleaf:switch -objscope:switch methodName cmd} {\n"
"::next::core::alias [::next::core::current object] $methodName \\\n"
"{*}[expr {${objscope} ? \"-objscope\" : \"\"}] \\\n"
"{*}[expr {${nonleaf} ? \"-nonleaf\" : \"\"}] \\\n"
"$cmd}\n"
"Object public method setter {methodName} {\n"
"::next::core::setter [::next::core::current object] -per-object $methodName}\n"
"Class public method setter {methodName} {\n"
"::next::core::setter [::next::core::current object] $methodName}\n"
"Object create ::next::objectInfo\n"
"Object create ::next::classInfo\n"
"objectInfo eval {\n"
":alias is ::next::core::objectproperty\n"
":public method info {obj} {\n"
"set methods [list]\n"
"foreach name [::next::core::cmd::ObjectInfo::methods [::next::core::current object]] {\n"
"if {$name eq \"unknown\"} continue\n"
"lappend methods $name}\n"
"return \"valid options are: [join [lsort $methods] {, }]\"}\n"
":method unknown {method obj args} {\n"
"error \"[::next::core::current object] unknown info option \\\"$method\\\"; [$obj info info]\"}}\n"
"classInfo eval {\n"
":alias is ::next::core::objectproperty\n"
":alias classparent ::next::core::cmd::ObjectInfo::parent\n"
":alias classchildren ::next::core::cmd::ObjectInfo::children\n"
":alias info [::next::core::cmd::ObjectInfo::method objectInfo name info]\n"
":alias unknown [::next::core::cmd::ObjectInfo::method objectInfo name info]}\n"
"foreach cmd [info command ::next::core::cmd::ObjectInfo::*] {\n"
"::next::core::alias ::next::objectInfo [namespace tail $cmd] $cmd\n"
"::next::core::alias ::next::classInfo [namespace tail $cmd] $cmd}\n"
"foreach cmd [info command ::next::core::cmd::ClassInfo::*] {\n"
"set cmdName [namespace tail $cmd]\n"
"if {$cmdName in [list \"object-mixin-of\" \"class-mixin-of\"]} continue\n"
"::next::core::alias ::next::classInfo $cmdName $cmd}\n"
"unset cmd\n"
"Object forward info -onerror ::next::core::infoError ::next::objectInfo %1 {%@2 %self}\n"
"Class forward  info -onerror ::next::core::infoError ::next::classInfo %1 {%@2 %self}\n"
"proc ::next::core::infoError msg {\n"
"regsub -all \" <object>\" $msg \"\" msg\n"
"regsub -all \" <class>\" $msg \"\" msg\n"
"regsub {\\\"} $msg \"\\\"info \" msg\n"
"error $msg \"\"}\n"
"Object method abstract {methtype -per-object:switch methname arglist} {\n"
"if {$methtype ne \"method\"} {\n"
"error \"invalid method type '$methtype', must be 'method'\"}\n"
"set body \"\n"
"if {!\\[::next::core::current isnextcall\\]} {\n"
"error \\\"Abstract method $methname $arglist called\\\"} else {::next::core::next}\n"
"\"\n"
"if {${per-object}} {\n"
":method -per-object $methname $arglist $body}  else {\n"
":method $methname $arglist $body}}\n"
"proc ::next::core::unsetExitHandler {} {\n"
"proc ::next::core::__exitHandler {} {}}\n"
"proc ::next::core::setExitHandler {newbody} {::proc ::next::core::__exitHandler {} $newbody}\n"
"proc ::next::core::getExitHandler {} {::info body ::next::core::__exitHandler}\n"
"::next::core::unsetExitHandler\n"
"namespace export Object Class next self}\n"
"namespace eval ::next {\n"
"::next::Class create ::next::MetaSlot\n"
"::next::core::relation ::next::MetaSlot superclass ::next::Class\n"
"::next::MetaSlot public method slotName {name baseObject} {\n"
"set slotParent ${baseObject}::slot\n"
"if {![::next::core::objectproperty ${slotParent} object]} {\n"
"::next::Object create ${slotParent}}\n"
"return ${slotParent}::$name}\n"
"::next::MetaSlot method createFromParameterSyntax {target -per-object:switch\n"
"{-initblock \"\"}\n"
"value default:optional} {\n"
"set opts [list]\n"
"set colonPos [string first : $value]\n"
"if {$colonPos == -1} {\n"
"set name $value} else {\n"
"set properties [string range $value [expr {$colonPos+1}] end]\n"
"set name [string range $value 0 [expr {$colonPos -1}]]\n"
"foreach property [split $properties ,] {\n"
"if {$property eq \"required\"} {\n"
"lappend opts -required 1} elseif {$property eq \"multivalued\"} {\n"
"lappend opts -multivalued 1} elseif {[string match type=* $property]} {\n"
"set type [string range $property 5 end]\n"
"if {![string match ::* $type]} {set type ::$type}} elseif {[string match arg=* $property]} {\n"
"set argument [string range $property 4 end]\n"
"lappend opts -arg $argument} else {\n"
"set type $property}}}\n"
"if {[info exists type]} {\n"
"lappend opts -type $type}\n"
"if {[info exists default]} {\n"
"lappend opts -default $default}\n"
"if {${per-object}} {\n"
"lappend opts -per-object true\n"
"set info ObjectInfo} else {\n"
"set info ClassInfo}\n"
":create [:slotName $name $target] {*}$opts $initblock\n"
"return [::next::core::cmd::${info}::method $target name $name]}\n"
"::next::MetaSlot create ::next::Slot\n"
"::next::MetaSlot create ::next::ObjectParameterSlot\n"
"::next::core::relation ::next::ObjectParameterSlot superclass ::next::Slot\n"
"::next::MetaSlot create ::next::MethodParameterSlot\n"
"::next::core::relation ::next::MethodParameterSlot superclass ::next::Slot\n"
"::next::MethodParameterSlot create ::next::methodParameterSlot\n"
"proc createBootstrapAttributeSlots {class definitions} {\n"
"foreach att $definitions {\n"
"if {[llength $att]>1} {foreach {att default} $att break}\n"
"set slotObj [::next::ObjectParameterSlot slotName $att $class]\n"
"::next::ObjectParameterSlot create $slotObj\n"
"if {[info exists default]} {\n"
"::next::core::setvar $slotObj default $default\n"
"unset default}\n"
"::next::core::setter $class $att}\n"
"foreach att $definitions {\n"
"if {[llength $att]>1} {foreach {att default} $att break}\n"
"if {[info exists default]} {\n"
"foreach i [::next::core::cmd::ClassInfo::instances $class] {\n"
"if {![$i exists $att]} {\n"
"if {[string match {*\\[*\\]*} $default]} {\n"
"set value [::next::core::dispatch $i -objscope ::eval subst $default]} else {\n"
"set value $default}\n"
"::next::core::setvar $i $att $value}}\n"
"unset default}}\n"
"$class __invalidateobjectparameter}\n"
"createBootstrapAttributeSlots ::next::Slot {\n"
"{name}\n"
"{multivalued false}\n"
"{required false}\n"
"default\n"
"type}\n"
"createBootstrapAttributeSlots ::next::ObjectParameterSlot {\n"
"{name \"[namespace tail [::next::core::current object]]\"}\n"
"{methodname}\n"
"{domain \"[lindex [regexp -inline {^(.*)::slot::[^:]+$} [::next::core::current object]] 1]\"}\n"
"{defaultmethods {get assign}}\n"
"{manager \"[::next::core::current object]\"}\n"
"{per-object false}}\n"
"::next::core::alias ::next::ObjectParameterSlot get ::next::core::setvar\n"
"::next::core::alias ::next::ObjectParameterSlot assign ::next::core::setvar\n"
"::next::ObjectParameterSlot public method add {obj prop value {pos 0}} {\n"
"if {![set :multivalued]} {\n"
"error \"Property $prop of [set :domain]->$obj ist not multivalued\"}\n"
"if {[$obj exists $prop]} {\n"
"::next::core::setvar $obj $prop [linsert [::next::core::setvar $obj $prop] $pos $value]} else {\n"
"::next::core::setvar $obj $prop [list $value]}}\n"
"::next::ObjectParameterSlot public method delete {-nocomplain:switch obj prop value} {\n"
"set old [::next::core::setvar $obj $prop]\n"
"set p [lsearch -glob $old $value]\n"
"if {$p>-1} {::next::core::setvar $obj $prop [lreplace $old $p $p]} else {\n"
"error \"$value is not a $prop of $obj (valid are: $old)\"}}\n"
"::next::ObjectParameterSlot method unknown {method args} {\n"
"set methods [list]\n"
"foreach m [:info callable] {\n"
"if {[::next::Object info callable $m] ne \"\"} continue\n"
"if {[string match __* $m]} continue\n"
"lappend methods $m}\n"
"error \"Method '$method' unknown for slot [::next::core::current object]; valid are: {[lsort $methods]}\"}\n"
"::next::ObjectParameterSlot public method destroy {} {\n"
"if {${:domain} ne \"\" && [::next::core::objectproperty ${:domain} class]} {\n"
"${:domain} __invalidateobjectparameter}\n"
"::next::core::next}\n"
"::next::ObjectParameterSlot protected method init {args} {\n"
"if {${:domain} eq \"\"} {\n"
"set :domain [::next::core::current callingobject]}\n"
"if {${:domain} ne \"\"} {\n"
"if {![info exists :methodname]} {\n"
"set :methodname ${:name}}\n"
"if {[::next::core::objectproperty ${:domain} class]} {\n"
"${:domain} __invalidateobjectparameter}\n"
"if {${:per-object} && [info exists :default] } {\n"
"::next::core::setvar ${:domain} ${:name} ${:default}}\n"
"set cl [expr {${:per-object} ? \"Object\" : \"Class\"}]\n"
"::next::core::forward ${:domain} ${:name} \\\n"
"${:manager} \\\n"
"[list %1 [${:manager} defaultmethods]] %self \\\n"
"${:methodname}}}\n"
"::next::MetaSlot __invalidateobjectparameter\n"
"::next::ObjectParameterSlot method toParameterSyntax {{name:substdefault ${:name}}} {\n"
"set objparamdefinition $name\n"
"set methodparamdefinition \"\"\n"
"set objopts [list]\n"
"set methodopts [list]\n"
"set type \"\"\n"
"if {[info exists :required] && ${:required}} {\n"
"lappend objopts required\n"
"lappend methodopts required}\n"
"if {[info exists :type]} {\n"
"if {[string match ::* ${:type}]} {\n"
"set type [expr {[::next::core::objectproperty ${:type} metaclass] ? \"class\" : \"object\"}]\n"
"lappend objopts type=${:type}\n"
"lappend methodopts type=${:type}} else {\n"
"set type ${:type}}}\n"
"if {[info exists :multivalued] && ${:multivalued}} {\n"
"if {!([info exists :type] && ${:type} eq \"relation\")} {\n"
"lappend objopts multivalued} else {}}\n"
"if {[info exists :arg]} {\n"
"set prefix [expr {$type eq \"object\" || $type eq \"class\" ? \"type\" : \"arg\"}]\n"
"lappend objopts $prefix=${:arg}\n"
"lappend methodopts $prefix=${:arg}}\n"
"if {[info exists :default]} {\n"
"set arg ${:default}\n"
"if {[string match {*\\[*\\]*} $arg]} {\n"
"lappend objopts substdefault}} elseif {[info exists :initcmd]} {\n"
"set arg ${:initcmd}\n"
"lappend objopts initcmd}\n"
"if {[info exists :methodname]} {\n"
"if {${:methodname} ne ${:name}} {\n"
"lappend objopts arg=${:methodname}\n"
"lappend methodopts arg=${:methodname}}}\n"
"if {$type ne \"\"} {\n"
"set objopts [linsert $objopts 0 $type]\n"
"set methodopts [linsert $methodopts 0 $type]}\n"
"lappend objopts slot=[::next::core::current object]\n"
"if {[llength $objopts] > 0} {\n"
"append objparamdefinition :[join $objopts ,]}\n"
"if {[llength $methodopts] > 0} {\n"
"set methodparamdefinition [join $methodopts ,]}\n"
"if {[info exists arg]} {\n"
"lappend objparamdefinition $arg}\n"
"return [list oparam $objparamdefinition mparam $methodparamdefinition]}\n"
"proc ::next::core::parametersFromSlots {obj} {\n"
"set parameterdefinitions [list]\n"
"foreach slot [::next::objectInfo slotobjects $obj] {\n"
"if {[::next::core::objectproperty $obj type ::xotcl::Object] &&\n"
"([$slot name] eq \"mixin\" || [$slot name] eq \"filter\")} continue\n"
"array set \"\" [$slot toParameterSyntax]\n"
"lappend parameterdefinitions -$(oparam)}\n"
"return $parameterdefinitions}\n"
"::next::Object protected method objectparameter {{lastparameter __initcmd:initcmd,optional}} {\n"
"set parameterdefinitions [::next::core::parametersFromSlots [::next::core::current object]]\n"
"if {[::next::core::objectproperty [::next::core::current object] class]} {\n"
"lappend parameterdefinitions -parameter:method,optional}\n"
"lappend parameterdefinitions \\\n"
"-noinit:method,optional,noarg \\\n"
"-volatile:method,optional,noarg \\\n"
"{*}$lastparameter\n"
"return $parameterdefinitions}\n"
"::next::MetaSlot create ::next::RelationSlot\n"
"createBootstrapAttributeSlots ::next::RelationSlot {\n"
"{multivalued true}\n"
"{type relation}\n"
"{elementtype ::next::Class}}\n"
"::next::core::relation ::next::RelationSlot superclass ::next::ObjectParameterSlot\n"
"::next::core::alias ::next::RelationSlot assign ::next::core::relation\n"
"::next::RelationSlot protected method init {} {\n"
"if {${:type} ne \"relation\"} {\n"
"error \"RelationSlot requires type == \\\"relation\\\"\"}\n"
"::next::core::next}\n"
"::next::RelationSlot protected method delete_value {obj prop old value} {\n"
"if {[string first * $value] > -1 || [string first \\[ $value] > -1} {\n"
"if {${:elementtype} ne \"\" && ![string match ::* $value]} {\n"
"set value ::$value}\n"
"return [lsearch -all -not -glob -inline $old $value]} elseif {${:elementtype} ne \"\"} {\n"
"if {[string first :: $value] == -1} {\n"
"if {![::next::core::objectproperty $value object]} {\n"
"error \"$value does not appear to be an object\"}\n"
"set value [::next::core::dispatch $value -objscope ::next::core::current object]}\n"
"if {![::next::core::objectproperty ${:elementtype} class]} {\n"
"error \"$value does not appear to be of type ${:elementtype}\"}}\n"
"set p [lsearch -exact $old $value]\n"
"if {$p > -1} {\n"
"return [lreplace $old $p $p]} else {\n"
"error \"$value is not a $prop of $obj (valid are: $old)\"}}\n"
"::next::RelationSlot public method delete {-nocomplain:switch obj prop value} {\n"
"$obj $prop [:delete_value $obj $prop [$obj info $prop] $value]}\n"
"::next::RelationSlot public method get {obj prop} {\n"
"::next::core::relation $obj $prop}\n"
"::next::RelationSlot public method add {obj prop value {pos 0}} {\n"
"if {![set :multivalued]} {\n"
"error \"Property $prop of ${:domain}->$obj ist not multivalued\"}\n"
"set oldSetting [::next::core::relation $obj $prop]\n"
"uplevel [list ::next::core::relation $obj $prop [linsert $oldSetting $pos $value]]}\n"
"::next::RelationSlot public method delete {-nocomplain:switch obj prop value} {\n"
"uplevel [list ::next::core::relation $obj $prop [:delete_value $obj $prop [::next::core::relation $obj $prop] $value]]}\n"
"proc ::next::core::register_system_slots {os} {\n"
"${os}::Object alloc ${os}::Class::slot\n"
"${os}::Object alloc ${os}::Object::slot\n"
"::next::RelationSlot create ${os}::Class::slot::superclass\n"
"::next::core::alias         ${os}::Class::slot::superclass assign ::next::core::relation\n"
"::next::RelationSlot create ${os}::Object::slot::class -multivalued false\n"
"::next::core::alias         ${os}::Object::slot::class assign ::next::core::relation\n"
"::next::RelationSlot create ${os}::Object::slot::mixin -methodname object-mixin\n"
"::next::RelationSlot create ${os}::Object::slot::filter -elementtype \"\"\n"
"::next::RelationSlot create ${os}::Class::slot::mixin -methodname class-mixin\n"
"::next::RelationSlot create ${os}::Class::slot::filter -elementtype \"\" \\\n"
"-methodname class-filter\n"
"::next::RelationSlot create ${os}::Class::slot::object-mixin\n"
"::next::RelationSlot create ${os}::Class::slot::object-filter -elementtype \"\"}\n"
"::next::core::register_system_slots ::next\n"
"proc ::next::core::register_system_slots {} {}\n"
"::next::MetaSlot __invalidateobjectparameter\n"
"::next::MetaSlot create ::next::Attribute -superclass ::next::ObjectParameterSlot\n"
"createBootstrapAttributeSlots ::next::Attribute {\n"
"{value_check once}\n"
"incremental\n"
"initcmd\n"
"valuecmd\n"
"valuechangedcmd\n"
"arg}\n"
"::next::Attribute method __default_from_cmd {obj cmd var sub op} {\n"
"$obj trace remove variable $var $op [list [::next::core::current object] [::next::core::current method] $obj $cmd]\n"
"::next::core::setvar $obj $var [$obj eval $cmd]}\n"
"::next::Attribute method __value_from_cmd {obj cmd var sub op} {\n"
"::next::core::setvar $obj $var [$obj eval $cmd]}\n"
"::next::Attribute method __value_changed_cmd {obj cmd var sub op} {\n"
"eval $cmd}\n"
"::next::Attribute protected method init {} {\n"
"::next::core::next ;# do first ordinary slot initialization\n"
"set __initcmd \"\"\n"
"if {[:exists default]} {} elseif [:exists initcmd] {\n"
"append __initcmd \":trace add variable [list ${:name}] read \\\n"
"\\[list [::next::core::current object] __default_from_cmd \\[::next::core::current object\\] [list [set :initcmd]]\\]\\n\"} elseif [:exists valuecmd] {\n"
"append __initcmd \":trace add variable [list ${:name}] read \\\n"
"\\[list [::next::core::current object] __value_from_cmd \\[::next::core::current object\\] [list [set :valuecmd]]\\]\"}\n"
"array set \"\" [:toParameterSyntax ${:name}]\n"
"if {$(mparam) ne \"\"} {\n"
"if {[info exists :multivalued] && ${:multivalued}} {\n"
":method assign [list obj var value:$(mparam),multivalued,slot=[::next::core::current object]] {\n"
"::next::core::setvar $obj $var $value}\n"
":method add [list obj prop value:$(mparam),slot=[::next::core::current object] {pos 0}] {\n"
"::next::core::next}} else {\n"
":method assign [list obj var value:$(mparam),slot=[::next::core::current object]] {\n"
"::next::core::setvar $obj $var $value}}}\n"
"if {[:exists valuechangedcmd]} {\n"
"append __initcmd \":trace add variable [list ${:name}] write \\\n"
"\\[list [::next::core::current object] __value_changed_cmd \\[::next::core::current object\\] [list [set :valuechangedcmd]]\\]\"}\n"
"if {$__initcmd ne \"\"} {\n"
"set :initcmd $__initcmd}}\n"
"::next::Class create ::next::Attribute::Optimizer {\n"
":method method args  {::next::core::next; :optimize}\n"
":method forward args {::next::core::next; :optimize}\n"
":protected method init args {::next::core::next; :optimize}\n"
":public method optimize {} {\n"
"if {![info exists :methodname]} {return}\n"
"set object [expr {${:per-object} ? {object} : {}}]\n"
"if {${:per-object}} {\n"
"set perObject -per-object\n"
"set infokind Object} else {\n"
"set perObject \"\"\n"
"set infokind Class}\n"
"if {[::next::core::cmd::${infokind}Info::method ${:domain} name ${:name}] ne \"\"} {\n"
"::next::core::forward ${:domain} {*}$perObject ${:name} \\\n"
"${:manager} \\\n"
"[list %1 [${:manager} defaultmethods]] %self \\\n"
"${:methodname}}\n"
"if {[info exists :incremental] && ${:incremental}} return\n"
"if {[set :defaultmethods] ne {get assign}} return\n"
"set assignInfo [:info callable -which assign]\n"
"if {$assignInfo ne \"::next::ObjectParameterSlot alias assign ::next::core::setvar\" &&\n"
"[lindex $assignInfo {end 0}] ne \"::next::core::setvar\" } return\n"
"if {[:info callable -which get] ne \"::next::ObjectParameterSlot alias get ::next::core::setvar\"} return\n"
"array set \"\" [:toParameterSyntax ${:name}]\n"
"if {$(mparam) ne \"\"} {\n"
"set setterParam [lindex $(oparam) 0]} else {\n"
"set setterParam ${:name}}\n"
"::next::core::setter ${:domain} {*}$perObject $setterParam}}\n"
"::next::Attribute mixin add ::next::Attribute::Optimizer\n"
"::next::Class method attribute {spec {-slotclass ::next::Attribute} {initblock \"\"}} {\n"
"$slotclass createFromParameterSyntax [::next::core::current object] -initblock $initblock {*}$spec}\n"
"::next::Object method attribute {spec {-slotclass ::next::Attribute} {initblock \"\"}} {\n"
"$slotclass createFromParameterSyntax [::next::core::current object] -per-object -initblock $initblock {*}$spec}\n"
"::next::Class public method parameter arglist {\n"
"foreach arg $arglist {\n"
"::next::Attribute createFromParameterSyntax [::next::core::current object] {*}$arg}\n"
"set slot [::next::core::current object]::slot\n"
"if {![::next::core::objectproperty $slot object]} {::next::Object create $slot}\n"
"::next::core::setvar $slot __parameter $arglist}\n"
"proc createBootstrapAttributeSlots {} {}\n"
"::next::Slot method type=hasmixin {name value arg} {\n"
"if {![::next::core::objectproperty $value hasmixin $arg]} {\n"
"error \"expected object with mixin $arg but got \\\"$value\\\" for parameter $name\"}\n"
"return $value}\n"
"::next::Slot method type=baseclass {name value} {\n"
"if {![::next::core::objectproperty $value baseclass]} {\n"
"error \"expected baseclass but got \\\"$value\\\" for parameter $name\"}\n"
"return $value}\n"
"::next::Slot method type=metaclass {name value} {\n"
"if {![::next::core::objectproperty $value metaclass]} {\n"
"error \"expected metaclass but got \\\"$value\\\" for parameter $name\"}\n"
"return $value}}\n"
"::next::Class create ::next::ScopedNew -superclass ::next::Class {\n"
":attribute {withclass ::next::Object}\n"
":attribute container\n"
":protected method init {} {\n"
":public method new {-childof args} {\n"
"::next::core::importvar [::next::core::current class] {container object} withclass\n"
"if {![::next::core::objectproperty $object object]} {\n"
"$withclass create $object}\n"
"eval ::next::core::next -childof $object $args}}}\n"
"::next::Object public method contains {\n"
"{-withnew:boolean true}\n"
"-object\n"
"{-class ::next::Object}\n"
"cmds} {\n"
"if {![info exists object]} {set object [::next::core::current object]}\n"
"if {![::next::core::objectproperty $object object]} {$class create $object}\n"
"$object requireNamespace\n"
"if {$withnew} {\n"
"set m [::next::ScopedNew new -volatile \\\n"
"-container $object -withclass $class]\n"
"::next::Class mixin add $m end\n"
"if {[::next::core::objectproperty ::xotcl::Class class]} {::xotcl::Class instmixin add $m end}\n"
"namespace eval $object $cmds\n"
"::next::Class mixin delete $m\n"
"if {[::next::core::objectproperty ::xotcl::Class class]} {::xotcl::Class instmixin delete $m}} else {\n"
"namespace eval $object $cmds}}\n"
"::next::Class forward slots %self contains \\\n"
"-object {%::next::core::dispatch [::next::core::current object] -objscope ::subst [::next::core::current object]::slot}\n"
"::next::Class create ::next::CopyHandler {\n"
":attribute {targetList \"\"}\n"
":attribute {dest \"\"}\n"
":attribute objLength\n"
":method makeTargetList {t} {\n"
"lappend :targetList $t\n"
"if {[::next::core::objectproperty $t object]} {\n"
"if {[$t info hasnamespace]} {\n"
"set children [$t info children]} else {\n"
"return}}\n"
"foreach c [namespace children $t] {\n"
"if {![::next::core::objectproperty $c object]} {\n"
"lappend children [namespace children $t]}}\n"
"foreach c $children {\n"
":makeTargetList $c}}\n"
":method copyNSVarsAndCmds {orig dest} {\n"
"::next::core::namespace_copyvars $orig $dest\n"
"::next::core::namespace_copycmds $orig $dest}\n"
":method getDest origin {\n"
"set tail [string range $origin [set :objLength] end]\n"
"return ::[string trimleft [set :dest]$tail :]}\n"
":method copyTargets {} {\n"
"foreach origin [set :targetList] {\n"
"set dest [:getDest $origin]\n"
"if {[::next::core::objectproperty $origin object]} {\n"
"if {[::next::core::objectproperty $origin class]} {\n"
"set cl [[$origin info class] create $dest -noinit]\n"
"set obj $cl\n"
"$cl superclass [$origin info superclass]\n"
"::next::core::assertion $cl class-invar [::next::core::assertion $origin class-invar]\n"
"::next::core::relation $cl class-filter [::next::core::relation $origin class-filter]\n"
"::next::core::relation $cl class-mixin [::next::core::relation $origin class-mixin]\n"
":copyNSVarsAndCmds ::next::core::classes$origin ::next::core::classes$dest} else {\n"
"set obj [[$origin info class] create $dest -noinit]}\n"
"::next::core::assertion $obj check [::next::core::assertion $origin check]\n"
"::next::core::assertion $obj object-invar [::next::core::assertion $origin object-invar]\n"
"::next::core::relation $obj object-filter [::next::core::relation $origin object-filter]\n"
"::next::core::relation $obj object-mixin [::next::core::relation $origin object-mixin]\n"
"if {[$origin info hasnamespace]} {\n"
"$obj requireNamespace}} else {\n"
"namespace eval $dest {}}\n"
":copyNSVarsAndCmds $origin $dest\n"
"foreach i [::next::core::cmd::ObjectInfo::forward $origin] {\n"
"eval [concat ::next::core::forward $dest -per-object $i [::next::core::cmd::ObjectInfo::forward $origin -definition $i]]}\n"
"if {[::next::core::objectproperty $origin class]} {\n"
"foreach i [::next::core::cmd::ClassInfo::forward $origin] {\n"
"eval [concat ::next::core::forward $dest $i [::next::core::cmd::ClassInfo::forward $origin -definition $i]]}}\n"
"set traces [list]\n"
"foreach var [$origin info vars] {\n"
"set cmds [::next::core::dispatch $origin -objscope ::trace info variable $var]\n"
"if {$cmds ne \"\"} {\n"
"foreach cmd $cmds {\n"
"foreach {op def} $cmd break\n"
"if {[lindex $def 0] eq $origin} {\n"
"set def [concat $dest [lrange $def 1 end]]}\n"
"$dest trace add variable $var $op $def}}}}\n"
"foreach origin [set :targetList] {\n"
"if {[::next::core::objectproperty $origin class]} {\n"
"set dest [:getDest $origin]\n"
"foreach oldslot [$origin info slots] {\n"
"set newslot [::next::Slot slotName [namespace tail $oldslot] $dest]\n"
"if {[$oldslot domain] eq $origin}   {$newslot domain $cl}\n"
"if {[$oldslot manager] eq $oldslot} {$newslot manager $newslot}}}}}\n"
":public method copy {obj dest} {\n"
"set :objLength [string length $obj]\n"
"set :dest $dest\n"
":makeTargetList $obj\n"
":copyTargets}}\n"
"::next::Object public method copy newName {\n"
"if {[string compare [string trimleft $newName :] [string trimleft [::next::core::current object] :]]} {\n"
"[::next::CopyHandler new -volatile] copy [::next::core::current object] $newName}}\n"
"::next::Object public method move newName {\n"
"if {[string trimleft $newName :] ne [string trimleft [::next::core::current object] :]} {\n"
"if {$newName ne \"\"} {\n"
":copy $newName}\n"
"if {[::next::core::objectproperty [::next::core::current object] class] && $newName ne \"\"} {\n"
"foreach subclass [:info subclass] {\n"
"set scl [$subclass info superclass]\n"
"if {[set index [lsearch -exact $scl [::next::core::current object]]] != -1} {\n"
"set scl [lreplace $scl $index $index $newName]\n"
"$subclass superclass $scl}}	}\n"
":destroy}}\n"
"namespace eval ::next::core {\n"
"proc tmpdir {} {\n"
"foreach e [list TMPDIR TEMP TMP] {\n"
"if {[info exists ::env($e)] \\\n"
"&& [file isdirectory $::env($e)] \\\n"
"&& [file writable $::env($e)]} {\n"
"return $::env($e)}}\n"
"if {$::tcl_platform(platform) eq \"windows\"} {\n"
"foreach d [list \"C:\\\\TEMP\" \"C:\\\\TMP\" \"\\\\TEMP\" \"\\\\TMP\"] {\n"
"if {[file isdirectory $d] && [file writable $d]} {\n"
"return $d}}}\n"
"return /tmp}\n"
"proc use {version} {\n"
"set callingNs [uplevel {namespace current}]\n"
"switch -exact $version {\n"
"xotcl -\n"
"xotcl1 {\n"
"package require XOTcl\n"
"if {$callingNs ne \"::xotcl\"} {uplevel {namespace import -force ::xotcl::*}}}\n"
"default {\n"
"if {$callingNs ne \"::xotcl\"} {uplevel {namespace import -force ::xotcl::*}}\n"
"if {$callingNs ne \"::next\"} {uplevel {namespace import -force ::next::*}}}}}\n"
"namespace export tmpdir use}\n"
"namespace eval ::next {\n"
"namespace export Attribute current\n"
"if {![info exists ::env(HOME)]} {set ::env(HOME) /root}\n"
"set ::next::confdir ~/.xotcl\n"
"set ::next::logdir $::next::confdir/log\n"
"unset bootstrap}\n"
"";

