[comment {-*- tcl -*- nx::Class manpage}]
[manpage_begin nx::Class n 2.0b6]

[keywords base-metaclass]
[keywords NX]
[keywords "mixin class"]
[keywords "re-classification"]
[keywords "submethod"]
[keywords "method ensemble"]
[keywords "linearisation"]
[term "filter specification"]

[vset SCOPE "class"]
[vset CMD "cls"]
[vset MODIFIER ""]

[copyright {2014 Stefan Sobernig <stefan.sobernig@wu.ac.at>, Gustaf Neumann <gustaf.neumann@wu.ac.at>}]
[titledesc {nx::Class API Reference}]

[description]
[para]

[cmd nx::Class] is the [term base-metaclass] of the [term NX] object
system. All application classes defined in [term NX] are (direct or indirect)
instances of this [cmd nx::Class]. The methods provided by [cmd nx::Class] are
available to all application classes. A custom metaclass instantiates [cmd nx::Class] and
subclasses [cmd nx::Class] at the same time.

[list_begin definitions]

[call [cmd nx::Class] [method create] [arg className] [opt "[option -superclass] [arg superClassNames]"] [opt "[option -mixin] [arg mixinSpec]"] [opt "[option -filter] [arg filterSpec]"] [opt "[arg option] [arg value] ..."] [opt [arg initBlock]]]

To create an application class having an explicit [arg className], use [method create].

  
  [call [cmd nx::Class] [method new] [opt "[option -superclass] [arg superClassNames]"] [opt "[option -mixin] [arg mixinSpec]"] [opt "[option -filter] [arg filterSpec]"] [opt [arg initBlock]]]

To create an application class having an automatically assigned, implicit object name, use [method new].

[list_end]

The configuration options for direct instances of [cmd nx::Class],
which can be passed when calling [method create] and [method new], are
documented in the subsequent section.

[section {Configuration Options for Instances of nx::Class}]

[para] Configuration options can be used for configuring objects during
their creation by passing the options as non-positional arguments into calls
of [method new] and [method create] (see [cmd nx::Class]). An
existing object can be queried for its current configuration using
[method cget] and it can be re-configured using [method configure].

[list_begin options]

[opt_def -superclass [opt [arg superClassNames]]]

If [arg superClassNames] is not specified, returns the superclasses of
the class. If provided, the class becomes the subclass of [arg superClassNames].

[opt_def -filter [opt [arg filterSpecs]]]

Retrieves the list of filter methods currently active on instances of
the class, if [arg filterSpecs] is not set. Otherwise, activates a
list of filter methods for the instances of the class. Filters are
returned or set in terms of a list of [term "filter specification"]s.

[opt_def -mixin [opt [arg mixinSpecs]]]

Returns the list of [term "mixin class"]es currently active on
instances of the class, if [arg mixinSpecs] is not specified. Otherwise, the class
is extended by the list of [term "mixin class"]es provided by [arg mixinSpecs]. 
[term "mixin class"]es are returned or set in terms of a list of [term "mixin specification"]s.

[list_end]

The configuration options provided by [cmd nx::Object] are equally
available because an application class [arg className] are indirect
instances of [cmd nx::Object].

[section {Methods for Instances of nx::Class}]

[list_begin commands]

[cmd_def alias]
[list_begin definitions]

[include alias.man.inc]

[list_end]

[cmd_def create]

[list_begin definitions]

[call [arg cls] [method create] [arg className] [opt "[arg option] [arg value] ..."]] 

This factory method creates a new application class having an explicit [arg className] and
returns [arg className]. [method create] accepts the configuration
options defined by [cmd nx::Class] and [cmd nx::Object] as arguments:

[example {
  % ::nx::Class create AClass; # defines a new class 'AClass'
  ::AClass
  % ::AClass create anInstance; # defines an instance 'anInstance' of 'AClass'
  % # create must be invoked explicitly; the following fails:
  % ::nx::Class AnotherClass; # "Method 'AnotherClass' unknown for ::nx::Class."
}]

Note that [method create] is called internally when defining a class
using [method new].

[para]

The factory method creates the new class in three major steps:
[example {
  [Class create AClass]                   (1)
                        ---------------.   .--------------.
        -------------->|Class->create()|-->|Class->alloc()|
                       `---------------'   `--------------'
                                 |  |  (2) .-------------------.
                                 |  .----->|Object->configure()|
                                 |         `-------------------'
                                 |   (3)   .------.
                                 .........>|init()|
                                           `------'
}]

[list_begin enumerated]

[enum] A call to the [term protected] [method "alloc"] provided by
[cmd nx::Class] creates the memory structures and then a raw,
uninitalized instance of [arg cls].
  
[enum] The newly allocated instance is then configured by receiving a
  call to its [method configure] which consumes the configuration
  options passed into [method create]. This will establish the
  instance's initial state, e.g., by setting the configuration options
  and corresponding default values.
  
[enum] [method create] then calls the initialization method [method init], if
available. The [method "init"] method can be defined by [arg cls] on
behalf of instances, e.g., to lay out a class-specific initialisation
behaviour. Alternatively or in addition, an instance may define an
[method init] method on its own.
[list_end]

[para]

[comment {
  # Provides for creating application-level classes and objects. If
  # the method receiver is a <<@gls metaclass>>, a <<@gls class>> will be
  # created. Otherwise, '''create''' yields an object. '''create'''
  # is responsible a multi-phase object creation scheme. This
  # creation scheme involves three major steps:
  # '''
  # [Object create anObject]               (1)
  #                       ---------------.   .--------------.
  #       -------------->|Class->create()|-->|Class->alloc()|
  #                      `---------------'   `--------------'
  #                                |  |  (2) .-------------------.
  #                                |  .----->|Object->configure()|
  #                                |         `-------------------'
  #                                |   (3)   .------.
  #                                .........>|init()|
  #                                          `------'
  # '''
  # (1) A call to <<@class.method "::nx::Class alloc">> to create a raw,
  # uninitalized object.
  #
  # (2) The newly allocated object receives a method call upon
  # <<@class.method "::nx::Object configure">>. This will establish the
  # object's initial state, by applying <<@gls objparam>> values
  # provided at object creation time and default values defined at
  # object definition time.
  #
  # (3) Finally, '''create''' emits a call to the initialization method
  # '''init''', if available. An '''init''' method can be defined by a
  # class on behalf of its objects, to lay out class-specific
  # initialisation behaviour. Alternatively, each single object may
  # define an '''init''' method on its own.
  #
  # By overloading the method in a <<@gls metaclass>>, you can refine or
  # replace this default object creation scheme (e.g., for applying
  # application-specific naming schemes).
  #
  #
  # @parameter name The designated identifier on the class or the object to be created.
  # @parameter args arguments to be passed down to the object creation
  # procedure used to initialize the object.
  # @return The fully qualified name of the created object.
}]


[list_end]

[cmd_def delete]

[list_begin definitions]

[include delete.man.inc]

[list_end]

[cmd_def filter]

[list_begin definitions]

[include filter.man.inc]

[list_end]

[cmd_def forward]

[list_begin definitions]

[include forward.man.inc]

[list_end]

[cmd_def info]

A collection of introspection submethods on the structural features (e.g.,
configuration options, superclasses) and the behavioral features (e.g.,
methods, [term "filter"]s) provided by [arg cls] to its instances.

[list_begin definitions]

[call [arg cls] [method "info heritage"] [opt [arg pattern]]]

If [arg pattern] is omitted, returns the list of object names of all the direct and indirect
superclasses and [emph per-class] [term "mixin class"]es of [arg cls], in
their order of precedence, which are active for instances of [arg cls]. If
[arg pattern] is specified, only superclasses and [term "mixin class"]es whose names
match [arg pattern] will be listed (see [cmd "string match"]).

[call [arg cls] [method "info instances"] [opt [option -closure]] [opt [arg pattern]]]

If [arg pattern] is not specified, returns a list of the object names
of all the direct and/or indirect instances of [arg cls]. A direct
instance is created by using [method create] or [method new] on [arg cls], an
indirect instance was created from a direct or indirect subclass of
[arg cls]. If the [term "switch"] [option -closure] is
set, indirect instances are also
returned; otherwise, only direct instances will be returned. If [arg pattern] is
specified, only instances whose names match [arg pattern] will
be listed (see [cmd "string match"]).

[call [arg cls] [method "info mixinof"] [opt [option -closure]] [opt "[option -scope] [arg option]"] [opt [arg pattern]]]

If [arg pattern] is not specified, returns a list of the object names
of all the objects for which [arg cls] is active as a
direct and/or indirect [term "mixin class"]. If the [term "switch"]
[option -closure] is set, objects which have [arg cls] as an indirect
[term "mixin class"] are also returned; otherwise,
only those having [arg cls] as a direct [term "mixin class"]. If [arg pattern] is
specified, only objects whose names match [arg pattern] will
be listed (see [cmd "string match"]). Valid values of [arg option] are
[const all], [const object], and [const class]. Passing [const object]
will have only objects returned which have [arg cls] as [emph per-object]
[term "mixin class"]. Passing [const class] will have only classes
returned which have [arg cls] as [emph per-class] [term "mixin class"]. [const all] (the
default) will have contained both in the returned list.


[call [arg cls] [method "info subclass"] [opt [option -closure]] [opt [option -dependent]] [opt [arg pattern]]]

If [arg pattern] is not specified, returns a list of the object names
of all the direct and/or indirect subclasses of [arg cls]. If the [term "switch"] [option -closure] is
set, indirect subclasses are also returned; otherwise, only direct subclasses will be returned. If the [term "switch"] [option -dependent] is on, indirect subclasses introduced by [term "mixin class"] relations of subclasses of [arg cls] are also reported. [option -closure] and [option -dependent] are mutually exclusive. If [arg pattern] is specified, only subclasses whose names match [arg pattern] will be listed (see [cmd "string match"]).

[comment {
  fixme: 
  % C info subclass 1 2 3 4 5
  invalid argument '2', maybe too many arguments; should be "::C subclass ?-closure? ?/pattern/?"
  ::C ::nx::Class->info
  invoked from within
  "C info subclass 1 2 3 4 5"
}]

[call [arg cls] [method "info superclass"] [opt [option -closure]] [opt [arg pattern]]]

If [arg pattern] is not specified, returns a list of the object names
of all the direct and/or indirect superclasses of [arg cls]. If the [term "switch"] [option -closure] is
set, indirect superclasses are also returned; otherwise, only direct superclasses will be returned. If [arg pattern] is specified, only superclasses whose names match [arg pattern] will be listed (see [cmd "string match"]).

[include info.man.inc]

[list_end]


[cmd_def method]

[list_begin definitions]

[include method.man.inc]

[list_end]

[cmd_def mixin]
[list_begin definitions]

[include mixin.man.inc]

[list_end]

[cmd_def require]

[list_begin definitions]

[include require.man.inc]

[list_end]

[cmd_def property]

[list_begin definitions]

[call [arg cls] [method property] [opt "[option -accessor] public | protected | private"] [opt "[option -configurable] [arg trueFalse]"] [opt [option -incremental]] [opt "[option -class] [arg className]"] [opt [option -nocomplain]] [arg spec] [opt [arg initBlock]]]

[include property.man.inc]

[para]

By default, the [term property] will ascertain that no (potentially)
pre-existing and equally named object variable will be overwritten
when defining the property. In case of a conflict, an error exception
is thrown:

[example {
% Object create obj { set :x 1 }
::obj
% ::obj object property {x 2}
object ::obj has already an instance variable named 'x'
}]

If the [term switch] [option -nocomplain] is on, this check is omitted (continuing the above example):

[example {
% ::obj object property -nocomplain {x 2}
% ::obj eval {set :x}
2
}]

[list_end]

[cmd_def variable]

[list_begin definitions]

[comment {::nx::Object variable ?-accessor /value/? ?-incremental? ?-class /value/? ?-configurable /boolean/? ?-initblock /value/? ?-nocomplain? /spec/ ?/defaultValue/?}]

[call [arg cls] [method variable] [opt "[option -accessor] public | protected | private"] [opt [option -incremental]] [opt "[option -class] [arg className]"] [opt "[option -configurable] [arg trueFalse]"] [opt "[option -initblock] [arg script]"] [opt [option -nocomplain]] [arg spec] [opt [arg defaultValue]]]

[include variable.man.inc]

[para]

By default, the [term variable] will ascertain that a
pre-existing and equally named object variable will not be overwritten
when defining the [term variable]. In case of a conflict, an error exception
is thrown:

[example {
% Object create obj { set :x 1 }
::obj
% ::obj object variable x 2
object ::obj has already an instance variable named 'x'
}]

If the [term switch] [option -nocomplain] is on, this check is omitted (continuing the above example):

[example {
% ::obj object variable -nocomplain x 2
% ::obj eval {set :x}
2
}]

[list_end]

[list_end]

[comment { COMMANDS list }]

[comment {
  [cmd nx::Object] provides a set of default implementations for
  internally called methods, which are called primarily during the 
  creation or destruction of NX objects.
  
  Application developers can provide custom implementations of these
  methods by providing tailored implementations for these methods in application
  classes (i.e., subclasses of [cmd nx::Object]). An adequate method
  implementation must comply with the method signature interfaces described below.
}]

[manpage_end]
