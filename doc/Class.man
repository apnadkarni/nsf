[comment {-*- tcl -*- nx::Class manpage}]
[manpage_begin nx::Class n 2.0b6]

[keywords base-metaclass]
[keywords NX]
[keywords "mixin class"]
[keywords "re-classification"]
[keywords "submethod"]
[keywords "method ensemble"]
[keywords "linearisation"]
[keywords "filter specification"]
[keywords "metaclass"]

[vset SCOPE "class"]
[vset CMD "cls"]
[vset MODIFIER ""]

[copyright {2014 Stefan Sobernig <stefan.sobernig@wu.ac.at>, Gustaf Neumann <gustaf.neumann@wu.ac.at>}]
[titledesc {nx::Class API Reference}]

[description]
[para]

[cmd nx::Class] is the [term base-metaclass] of the [term NX] object
system. All application classes defined in [term NX] are (direct or indirect)
instances of this [cmd nx::Class]. The methods provided by [cmd nx::Class] are
available to all application classes. A custom metaclass instantiates [cmd nx::Class] and
subclasses [cmd nx::Class] at the same time.

[list_begin definitions]

[call [cmd nx::Class] [method create] [arg className] [opt "[option -superclass] [arg superClassNames]"] [opt "[option -mixin] [arg mixinSpec]"] [opt "[option -filter] [arg filterSpec]"] [opt "[arg option] [arg value] ..."] [opt [arg initBlock]]]

To create an application class having an explicit [arg className], use [method create].

  
  [call [cmd nx::Class] [method new] [opt "[option -superclass] [arg superClassNames]"] [opt "[option -mixin] [arg mixinSpec]"] [opt "[option -filter] [arg filterSpec]"] [opt [arg initBlock]]]

To create an application class having an automatically assigned, implicit object name, use [method new].

[list_end]

The configuration options for direct instances of [cmd nx::Class],
which can be passed when calling [method create] and [method new], are
documented in the subsequent section.

[section {Configuration Options for Instances of nx::Class}]

[para] Configuration options can be used for configuring objects during
their creation by passing the options as non-positional arguments into calls
of [method new] and [method create] (see [cmd nx::Class]). An
existing object can be queried for its current configuration using
[method cget] and it can be re-configured using [method configure].

[list_begin options]

[opt_def -superclass [opt [arg superClassNames]]]

If [arg superClassNames] is not specified, returns the superclasses of
the class. If provided, the class becomes the subclass of [arg superClassNames].

[opt_def -filter [opt [arg filterSpecs]]]

Retrieves the list of filter methods currently active on instances of
the class, if [arg filterSpecs] is not set. Otherwise, activates a
list of filter methods for the instances of the class. Filters are
returned or set in terms of a list of [term "filter specification"]s.

[opt_def -mixin [opt [arg mixinSpecs]]]

Returns the list of [term "mixin class"]es currently active on
instances of the class, if [arg mixinSpecs] is not specified. Otherwise, the class
is extended by the list of [term "mixin class"]es provided by [arg mixinSpecs]. 
[term "mixin class"]es are returned or set in terms of a list of [term "mixin specification"]s.

[list_end]

The configuration options provided by [cmd nx::Object] are equally
available because an application class [arg className] are indirect
instances of [cmd nx::Object].

[section {Methods for Instances of nx::Class}]

[list_begin commands]

[cmd_def alias]
[list_begin definitions]

[include alias.man.inc]

[list_end]

[cmd_def create]

[list_begin definitions]

[call [arg cls] [method create] [arg instanceName] [opt "[arg option] [arg value] [arg option] [arg value] ..."]] 

This factory method creates an instance [arg instanceName] of [arg cls]
and returns [arg instanceName].

[example {
% nx::Class create AClass {
    :method init args {
      next
    }; # initialization method for instances of 'AClass'
  }; # defines a class 'AClass' being an instance of 'nx::Class'
::AClass
% ::AClass create anInstance; # defines an object 'anInstance' being an instance of 'AClass'
::anInstance
% ::anInstance info class
::AClass
% ::AClass info class
::nx::Class
}]

[method create] accepts the configuration options [arg option]
available for this instance, such as those defined by properties of
[arg cls] (see [method "property"]).

[para]

The factory method creates the new class in three major steps:
[example {
  [Class create AClass]                   (1)
                        ---------------.   .--------------.
        -------------->|Class->create()|-->|Class->alloc()|
                       `---------------'   `--------------'
                                 |  |  (2) .-------------------.
                                 |  .----->|Object->configure()|
                                 |         `-------------------'
                                 |   (3)   .------.
                                 .........>|init()|
                                           `------'
}]

[list_begin enumerated]

[enum] A call to the [term protected] [method "alloc"] provided by
[cmd nx::Class] creates the memory structures and then a raw,
uninitalized instance of [arg cls].
  
[enum] The newly allocated instance is then configured by receiving a
  call to its [method configure] which consumes the configuration
  options passed into [method create]. This will establish the
  instance's initial state, e.g., by setting the configuration options
  and corresponding default values.
  
[enum] [method create] then calls the initialization method [method init], if
available. The [method "init"] method can be defined by [arg cls] on
behalf of instances, e.g., to lay out a class-specific initialisation
behaviour. Alternatively or in addition, an instance may define an
[method init] method on its own.
[list_end]

Note that [method create] is called internally when defining an
instance of [arg cls] using [method new].

[para]

By calling [method create] on [cmd nx::Class] itself, the created
instance will become a new application class [arg instanceName] on
which [method create] can also be applied (i.e., it can be
instantiated). If the so-created class has [cmd ::nx::Class] has its
direct or indirect superclass, [arg instanceName] is referred to as a
[term "metaclass"]; that is, a class whose instances are again
classes.

[list_end]

[cmd_def delete]

[list_begin definitions]

[include delete.man.inc]

[list_end]

[cmd_def filter]

[list_begin definitions]

[include filter.man.inc]

[list_end]

[cmd_def forward]

[list_begin definitions]

[include forward.man.inc]

[list_end]

[cmd_def info]

A collection of introspection submethods on the structural features (e.g.,
configuration options, superclasses) and the behavioral features (e.g.,
methods, [term "filter"]s) provided by [arg cls] to its instances.

[list_begin definitions]

[call [arg cls] [method "info heritage"] [opt [arg pattern]]]

If [arg pattern] is omitted, returns the list of object names of all the direct and indirect
superclasses and [emph per-class] [term "mixin class"]es of [arg cls], in
their order of precedence, which are active for instances of [arg cls]. If
[arg pattern] is specified, only superclasses and [term "mixin class"]es whose names
match [arg pattern] will be listed (see [cmd "string match"]).

[call [arg cls] [method "info instances"] [opt [option -closure]] [opt [arg pattern]]]

If [arg pattern] is not specified, returns a list of the object names
of all the direct and/or indirect instances of [arg cls]. A direct
instance is created by using [method create] or [method new] on [arg cls], an
indirect instance was created from a direct or indirect subclass of
[arg cls]. If the [term "switch"] [option -closure] is
set, indirect instances are also
returned; otherwise, only direct instances will be returned. If [arg pattern] is
specified, only instances whose names match [arg pattern] will
be listed (see [cmd "string match"]).

[call [arg cls] [method "info mixinof"] [opt [option -closure]] [opt "[option -scope] [arg option]"] [opt [arg pattern]]]

If [arg pattern] is not specified, returns a list of the object names
of all the objects for which [arg cls] is active as a
direct and/or indirect [term "mixin class"]. If the [term "switch"]
[option -closure] is set, objects which have [arg cls] as an indirect
[term "mixin class"] are also returned; otherwise,
only those having [arg cls] as a direct [term "mixin class"]. If [arg pattern] is
specified, only objects whose names match [arg pattern] will
be listed (see [cmd "string match"]). Valid values of [arg option] are
[const all], [const object], and [const class]. Passing [const object]
will have only objects returned which have [arg cls] as [emph per-object]
[term "mixin class"]. Passing [const class] will have only classes
returned which have [arg cls] as [emph per-class] [term "mixin class"]. [const all] (the
default) will have contained both in the returned list.


[call [arg cls] [method "info subclass"] [opt [option -closure]] [opt [option -dependent]] [opt [arg pattern]]]

If [arg pattern] is not specified, returns a list of the object names
of all the direct and/or indirect subclasses of [arg cls]. If the [term "switch"] [option -closure] is
set, indirect subclasses are also returned; otherwise, only direct subclasses will be returned. If the [term "switch"] [option -dependent] is on, indirect subclasses introduced by [term "mixin class"] relations of subclasses of [arg cls] are also reported. [option -closure] and [option -dependent] are mutually exclusive. If [arg pattern] is specified, only subclasses whose names match [arg pattern] will be listed (see [cmd "string match"]).

[call [arg cls] [method "info superclass"] [opt [option -closure]] [opt [arg pattern]]]

If [arg pattern] is not specified, returns a list of the object names
of all the direct and/or indirect superclasses of [arg cls]. If the [term "switch"] [option -closure] is
set, indirect superclasses are also returned; otherwise, only direct superclasses will be returned. If [arg pattern] is specified, only superclasses whose names match [arg pattern] will be listed (see [cmd "string match"]).

[include info.man.inc]

[list_end]


[cmd_def method]

[list_begin definitions]

[include method.man.inc]

[list_end]

[cmd_def mixin]
[list_begin definitions]

[include mixin.man.inc]

[list_end]

[cmd_def new]

[list_begin definitions]

[call [arg cls] [method new] [opt "[option "-childof"] [arg parentName]"] [opt "[arg option] [arg value] [arg option] [arg value] ..."]]

A factory method to create autonamed instances of [arg cls]. It
returns the name of the newly created instance. For example:

[example {
% nx::Class create AClass; # defines a class 'AClass' being an instance of 'nx::Class'
::AClass
% set inst [::AClass new]; # defines an autonamed object being an instance of 'AClass'
::anInstance
% $inst info class
::AClass
}]

The factory method will provide computed object names of the form,
e.g., ::nsf::__#0. The uniqueness of generated object names is
guaranteed for the scope of the current Tcl interpreter only.

[para]

It is a frontend to [method create] which will be called by [method new] once
the name of the instance has been computed, passing along the
arguments [arg option] to [method new] as the configuration options
(see [method create]).

[para]
If [option -childof] is provided, the new object will be created as a
nested object of [arg parentName]. [arg parentName] can be the name of
either an existing NX object or an existing Tcl namespace. If
non-existing, a Tcl namespace [arg parentName] will be created on the
fly.

[list_end]

[cmd_def require]

[list_begin definitions]

[include require.man.inc]

[list_end]

[cmd_def property]

[list_begin definitions]

[call [arg cls] [method property] [opt "[option -accessor] public | protected | private"] [opt "[option -configurable] [arg trueFalse]"] [opt [option -incremental]] [opt "[option -class] [arg className]"] [opt [option -nocomplain]] [arg spec] [opt [arg initBlock]]]

[include property.man.inc]

[para]

By default, the [term property] will ascertain that no (potentially)
pre-existing and equally named object variable will be overwritten
when defining the property. In case of a conflict, an error exception
is thrown:

[example {
% Object create obj { set :x 1 }
::obj
% ::obj object property {x 2}
object ::obj has already an instance variable named 'x'
}]

If the [term switch] [option -nocomplain] is on, this check is omitted (continuing the above example):

[example {
% ::obj object property -nocomplain {x 2}
% ::obj eval {set :x}
2
}]

[list_end]

[cmd_def variable]

[list_begin definitions]

[comment {::nx::Object variable ?-accessor /value/? ?-incremental? ?-class /value/? ?-configurable /boolean/? ?-initblock /value/? ?-nocomplain? /spec/ ?/defaultValue/?}]

[call [arg cls] [method variable] [opt "[option -accessor] public | protected | private"] [opt [option -incremental]] [opt "[option -class] [arg className]"] [opt "[option -configurable] [arg trueFalse]"] [opt "[option -initblock] [arg script]"] [opt [option -nocomplain]] [arg spec] [opt [arg defaultValue]]]

[include variable.man.inc]

[para]

By default, the [term variable] will ascertain that a
pre-existing and equally named object variable will not be overwritten
when defining the [term variable]. In case of a conflict, an error exception
is thrown:

[example {
% Object create obj { set :x 1 }
::obj
% ::obj object variable x 2
object ::obj has already an instance variable named 'x'
}]

If the [term switch] [option -nocomplain] is on, this check is omitted (continuing the above example):

[example {
% ::obj object variable -nocomplain x 2
% ::obj eval {set :x}
2
}]

[list_end]

[list_end]

[comment { COMMANDS list }]

[comment {
  [cmd nx::Object] provides a set of default implementations for
  internally called methods, which are called primarily during the 
  creation or destruction of NX objects.
  
  Application developers can provide custom implementations of these
  methods by providing tailored implementations for these methods in application
  classes (i.e., subclasses of [cmd nx::Object]). An adequate method
  implementation must comply with the method signature interfaces described below.
}]

[manpage_end]
