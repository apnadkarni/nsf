<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.6" />
<title>Tutorial for the Next Scripting Language</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }


/*
 * xhtml11 specific
 *
 * */

tt {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

.monospaced {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([2-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(4);
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>Tutorial for the Next Scripting Language</h1>
<span id="author">Gustaf Neumann &lt;neumann@wu-wien.ac.at&gt;, Stefan Sobernig &lt;stefan.sobernig@wu.ac.at&gt;</span><br />
<span id="revnumber">version 2.1,</span>
<span id="revdate">March 2011</span>
<br /><span id="revremark">Written for the Initial Release of the Next Scripting Framework.</span>
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="sidebarblock">
<div class="content">
<div class="title">Abstract</div>
<div class="paragraph"><p>This document provides a tutorial for the Next Scripting
Language NX.</p></div>
</div></div>
<div class="paragraph"><p>The Next Scripting Language (NX) is a highly flexible object oriented
scripting language based on Tcl <a href="#Ousterhout 1990">[Ousterhout 1990]</a>. NX is a successor
of XOTcl 1 <a href="#Neumann and Zdun 2000a">[Neumann and Zdun 2000a]</a> and was developed based on 10
years of experience with XOTcl in projects containing several hundred
thousand lines of code. While XOTcl was the first language designed to
provide <em>language support for design patterns</em>, the focus of the Next
Scripting Framework and NX is on combining this with <em>Language
Oriented Programming</em>. In many respects, NX was designed to ease the
learning of the language for novices (by using a more mainstream
terminology, higher orthogonality of the methods, less predefined
methods), to improve maintainability (remove sources of common errors)
and to encourage developers to write better structured programs (to
provide interfaces) especially for large projects, where many
developers are involved.</p></div>
<div class="paragraph"><p>The Next Scripting Language is based on the Next Scripting Framework
(NSF) which was developed based on the notion of language oriented
programming. The Next Scripting Frameworks provides C-level support
for defining and hosting multiple object systems in a single Tcl
interpreter.  The name of the Next Scripting Framework is derived from
the universal method combinator "next", which was introduced in XOTcl.
The combinator "next" serves as a single instrument for method
combination with filters, per-object and transitive per-class mixin
classes, per-object methods and multiple inheritance.</p></div>
<div class="paragraph"><p>The definition of NX is fully scripted (e.g.  defined in
<tt>nx.tcl</tt>). The Next Scripting Framework is shipped with three language
definitions, containing NX and XOTcl 2. Most of the existing XOTcl 1
programs can be used without modification in the Next Scripting
Framework by using XOTcl 2. The Next Scripting Framework requires Tcl
8.5 or newer.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_and_its_roots">1. NX and its Roots</h2>
<div class="sectionbody">
<div class="paragraph"><p>Object oriented extensions of Tcl have quite a
long history. Two of the most prominent early Tcl based OO languages
were <em>incr Tcl</em> (abbreviated as itcl) and Object Tcl (<em>OTcl</em>
<a href="#Wetherall and Lindblad 1995">[Wetherall and Lindblad 1995]</a>). While itcl provides a traditional
C++/Java-like object system, OTcl was following the CLOS approach and
supports a dynamic object system, allowing incremental class and
object extensions and re-classing of objects.</p></div>
<div class="paragraph"><p>Extended Object Tcl (abbreviated as XOTcl <a href="#Neumann and Zdun 2000a">[Neumann and Zdun 2000a]</a>)
is a successor of OTcl and was the first language providing language
support for design patterns. XOTcl extends OTcl by providing namespace
support, adding assertions, dynamic object aggregations, slots and by
introducing per-object and per-class filters and per-object and
per-class mixins.</p></div>
<div class="paragraph"><p>XOTcl was so far released in more than 30 versions. It is described in
its detail in more than 20 papers and serves as a basis for other
object systems like TclOO [Donal ???]. The scripting language <em>NX</em> and
the <em>Next Scripting Framework</em> <a href="#Neumann and Sobernig 2009">[Neumann and Sobernig 2009]</a> extend
the basic ideas of XOTcl by providing support for <em>language-oriented
programming</em>. The the Next Scripting Framework supports multiple
object systems concurrently. Effectively, every object system has
different base classes for creating objects and classes. Therefore,
these object systems can have different interfaces and can
follow different naming conventions for built-in methods. Currently,
the Next Scripting Framework is packaged with three object systems:
NX, XOTcl 2.0, and TclCool (the language introduced by TIP#279).</p></div>
<div class="imageblock" style="text-align:center;">
<div class="content">
<img src="languages.png" alt="Languages" width="500" />
</div>
<div class="title">Figure 1. Language History of the Next Scripting Language</div>
</div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>The primary purpose of this document is to introduce NX to beginners.
We expect some prior knowledge of programming languages, and some
knowledge about Tcl. In the following sections we introduce NX by
examples. In later sections we introduce the more advanced concepts of
the language. Conceptually, most of the addressed concepts are very
similar to XOTcl. Concerning the differences between NX and XOTcl,
please refer to the "Migration Guide for the Next Scripting Language".</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_introductory_overview_example_stack">2. Introductory Overview Example: Stack</h2>
<div class="sectionbody">
<div class="paragraph"><p>A classical programming example is the implementation of a stack, which
is most likely familiar to many readers from many introductory
programming courses. A stack is a last-in first-out data structure
which is manipulated via operations like <tt>push</tt> (add something to the
stack) and <tt>pop</tt> remove an entry from the stack. These operations are
called <em>methods</em> in the context of object oriented programming
systems. Primary goals of object orientation are encapsulation and
abstraction. Therefore, we define a common unit (a class) that defines
and encapsulates the behavior of a stack and provides methods to a user
of the data structure that abstract from the actual implementation.</p></div>
<div class="sect2">
<h3 id="_define_a_class_stack">2.1. Define a Class "Stack"</h3>
<div class="paragraph"><p>In our first example, we define a class named <tt>Stack</tt> with the methods
<tt>push</tt> and <tt>pop</tt>. When an instance of the stack is created (e.g. a
concrete stack <tt>s1</tt>) the stack will contain an instance variable named
<tt>things</tt>, initialized with the an empty list.</p></div>
<div class="paragraph" id="xmp-class-stack"><div class="title">Listing 2: Class Stack</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Stack {

   <span class='nx-comment'>#
</span>   <span class='nx-comment'># Stack of Things
</span>   <span class='nx-comment'>#
</span>
   <span class='nx-keyword'>:variable</span> things {}

   <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> push {thing} {
      <span class='nx-keyword'>set</span> :things [<span class='nx-keyword'>linsert</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 0 <span class='nx-variable'>$thing</span>]
      <span class='nx-keyword'>return</span> <span class='nx-variable'>$thing</span>
   }

   <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> pop {} {
      <span class='nx-keyword'>set</span> top [<span class='nx-keyword'>lindex</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 0]
      <span class='nx-keyword'>set</span> :things [<span class='nx-keyword'>lrange</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 1 end]
      <span class='nx-keyword'>return</span> <span class='nx-variable'>$top</span>
   }
}</pre></td></tr></table></div></div>
<div class="paragraph"><p>Typically, classes are defined in NX via <tt>nx::Class create</tt>, followed
by the name of the new class (here: <tt>Stack</tt>). The definition of the
stack placed between curly braces and contains here just the method
definitions. Methods of the class are defined via <tt>:method</tt> followed
by the name of the method, an argument list and the body of the
method, consisting of Tcl and NX statements.</p></div>
<div class="paragraph"><p>When an instance of <tt>Stack</tt> is created, it will contain an instance
variable named <tt>things</tt>. If several <tt>Stack</tt> instances are created,
each of the instances will have their own (same-named but different)
instance variable. The instance variable <tt>things</tt> is used in our
example as a list for the internal representation of the stack. We
define in a next step the methods to access and modify this list
structure. A user of the stack using the provided methods does not
have to have any knowledge about the name or the structure of the
internal representation (the instance variable <tt>things</tt>).</p></div>
<div class="paragraph"><p>The method <tt>push</tt> receives an argument <tt>thing</tt> which should be placed
on the stack. Note that we do not have to specify the type of the
element on the stack, so we can push strings as well as numbers or
other kind of things. When an element is pushed, we add this element
as the first element to the list <tt>things</tt>. We insert the element using
the Tcl command <tt>linsert</tt> which receives the list as first element,
the position where the element should be added as second and the new
element as third argument. To access the value of the instance
variable we use Tcl&#8217;s dollar operator followed by the name. The
names of instance variables are preceded with a colon <tt>:</tt>. Since the
name contains a non-plain character, Tcl requires us to put braces
around the name. The command <tt>linsert</tt> and its arguments are placed
between square brackets. This means that the function <tt>linsert</tt> is called and
a new list is returned, where the new element is inserted at the first
position (index 0) in the list <tt>things</tt>. The result of the <tt>linsert</tt>
function is assigned again to the instance variable <tt>things</tt>, which is
updated this way.  Finally the method <tt>push</tt> returns the pushed thing
using the <tt>return</tt> statement.</p></div>
<div class="paragraph"><p>The method <tt>pop</tt> returns the most recently stacked element and removes
it from the stack. Therefore, it takes the first element from the list
(using the Tcl command <tt>lindex</tt>), assigns it to the method-scoped
variable <tt>top</tt>, removes the element from the instance variable
<tt>things</tt> (by using the Tcl command <tt>lrange</tt>) and returns the value
popped element <tt>top</tt>.</p></div>
<div class="paragraph"><p>This finishes our first implementation of the stack, more enhanced
versions will follow. Note that the methods <tt>push</tt> and <tt>pop</tt> are
defined as <tt>public</tt>; this means that these methods can be
used from all other objects in the system. Therefore, these methods
provide an interface to the stack implementation.</p></div>
<div class="paragraph" id="xmp-using-stack"><div class="title">Listing 3: Using the Stack</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-comment'>#!/bin/env tclsh
</span><span class='nx-keyword'>package</span> <span class='nx-keyword'>require</span> nx

<span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Stack {

   <span class='nx-comment'>#
</span>   <span class='nx-comment'># Stack of Things
</span>   <span class='nx-comment'>#
</span>   ....
}

Stack <span class='nx-keyword'>create</span> s1
s1 push a
s1 push b
s1 push c
<span class='nx-keyword'>puts</span> [s1 pop]
<span class='nx-keyword'>puts</span> [s1 pop]
s1 <span class='nx-keyword'>destroy</span></pre></td></tr></table></div></div>
<div class="paragraph"><p>Now we want to use the stack. The code snippet in <a href="#xmp-using-stack">Listing 3</a> shows how to use the class Stack in a script.
Since NX is based on Tcl, the script will be called with the Tcl shell
<tt>tclsh</tt>. In the Tcl shell we have to <tt>require package nx</tt> to use the
Next Scripting Framework and NX. The next lines contain the definition
of the stack as presented before. Of course, it is as well possible to
make the definition of the stack an own package, such we could simple
say <tt>package require stack</tt>, or to save the definition of a stack
simply in a file and load it via <tt>source</tt>.</p></div>
<div class="paragraph"><p>In line 12 we create an instance of the stack, namely the stack object
<tt>s1</tt>. The object <tt>s1</tt> is an instance of <tt>Stack</tt> and has therefore
access to its methods. The methods like <tt>push</tt> or <tt>pop</tt> can be invoked
via a command starting with the object name followed by the
method name. In lines 13-15 we push on the stack the values <tt>a</tt>, then
<tt>b</tt>, and <tt>c</tt>. In line 16 we output the result of the <tt>pop</tt> method
using the Tcl command <tt>puts</tt>. We will see on standard output the
value+c+ (the last stacked item). The output of the line 17 is the
value <tt>b</tt> (the previously stacked item). Finally, in line 18 we
destroy the object. This is not necessary here, but shows the life
cycle of an object. In some respects, <tt>destroy</tt> is the counterpart of
<tt>create</tt> from line 12.</p></div>
<div class="imageblock" id="fig-class-object" style="text-align:center;">
<div class="content">
<img src="object-class-appclass.png" alt="object-class-appclass.png" />
</div>
<div class="title">Figure 4. Class and Object Diagram</div>
</div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p><a href="#fig-class-object">Figure 4</a> shows the actual class and
object structure of the first <tt>Stack</tt> example. Note that the common
root class is <tt>nx::Object</tt> that contains methods for all objects.
Since classes are as well objects in NX, <tt>nx::Class</tt> is a
specialization of <tt>nx::Object</tt>. <tt>nx::Class</tt> provides methods for
creating objects, such as the method <tt>create</tt> which is used to create
objects (and classes as well).</p></div>
</div>
<div class="sect2">
<h3 id="_define_an_object_named_stack">2.2. Define an Object Named "stack"</h3>
<div class="paragraph"><p>The definition of the stack in <a href="#xmp-class-stack">Listing 2</a>
follows the traditional object oriented approach, found in
practically every object oriented programming language: Define a class
with some methods, create instances from this class, and use the
methods defined in the class in the instances of the class.</p></div>
<div class="paragraph"><p>In our next example, we introduce <em>generic objects</em> and <em>object
specific methods</em>. With NX, we can define generic objects, which are
instances of the most generic class <tt>nx::Object</tt> (sometimes called
"common root class"). <tt>nx::Object</tt> is predefined and contains a
minimal set of methods applicable to all NX objects.</p></div>
<div class="paragraph"><p>In our second example, we will define a generic object named <tt>stack</tt>
and provide methods for this object. The methods defined in our first
example were methods provided by a class for objects. Now we defined
object specific methods, which are methods applicable only to the
object for which they are defined.</p></div>
<div class="paragraph" id="xmp-object-stack"><div class="title">Listing 5: Object stack</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Object</span> <span class='nx-keyword'>create</span> stack {

   <span class='nx-keyword'>:variable</span> things {}

   <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> push {thing} {
      <span class='nx-keyword'>set</span> :things [<span class='nx-keyword'>linsert</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 0 <span class='nx-variable'>$thing</span>]
      <span class='nx-keyword'>return</span> <span class='nx-variable'>$thing</span>
   }

   <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> pop {} {
      <span class='nx-keyword'>set</span> top [<span class='nx-keyword'>lindex</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 0]
      <span class='nx-keyword'>set</span> :things [<span class='nx-keyword'>lrange</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 1 end]
      <span class='nx-keyword'>return</span> <span class='nx-variable'>$top</span>
   }
}</pre></td></tr></table></div></div>
<div class="paragraph"><p>The example in <a href="#xmp-object-stack">Listing 5</a> defines the
object <tt>stack</tt> in a very similar way as the class <tt>Stack</tt>. But the
following points are different.</p></div>
<div class="ulist"><ul>
<li>
<p>
First, we use <tt>nx::Object</tt> instead of <tt>nx::Class</tt> to denote
  that we want to create a generic object, not a class.
</p>
</li>
<li>
<p>
As in the example above, we use <tt>:variable</tt> to define the
  instance variable <tt>things</tt> for this object (the object <tt>stack</tt>).
</p>
</li>
</ul></div>
<div class="paragraph"><p>The definition for the methods <tt>push</tt> and <tt>pop</tt> are the same as
before, but this times these methods are object-specific (in general,
all methods defined for an object are object-specific). In order to use
the stack, we can use directly the object <tt>stack</tt> in the same way as
we have used the object <tt>s1</tt> in <a href="#xmp-using-stack">Listing 3</a>
the class diagram for this the object <tt>stack</tt>.</p></div>
<div class="imageblock" id="img-object-stack" style="text-align:center;">
<div class="content">
<img src="object-stack.png" alt="object-stack.png" />
</div>
<div class="title">Figure 6. Object stack</div>
</div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>A reader might wonder when to use a class <tt>Stack</tt> or rather an object
<tt>stack</tt>. A big difference is certainly that one can define easily
multiple instances of a class, while the object is actually a
singleton. The concept of the object <tt>stack</tt> is similar to a module,
providing a certain functionality via a common interface, without
providing the functionality to create multiple instances. The reuse of
methods provided by the class to objects is as well a difference. If
the methods of the class are updated, all instances of the class will
immediately get the modified behavior. However, this does not mean that
the reuse for the methods of <tt>stack</tt> is not possible. NX allows for
example to copy objects (similar to prototype based languages) or to
reuse methods via e.g. aliases (more about this later).</p></div>
<div class="paragraph"><p>Note that we use capitalized names for classes and lowercase names for
instances. This is not required and a pure convention making it easier
to understand scripts without much analysis.</p></div>
</div>
<div class="sect2">
<h3 id="_implementing_features_using_mixin_classes">2.3. Implementing Features using Mixin Classes</h3>
<div class="paragraph"><p>So far, the definition of the stack methods was pretty minimal.
Suppose, we want to define "safe stacks" that protect e.g. against
stack under-runs (a stack under-run happens, when more <tt>pop</tt> than
<tt>push</tt> operations are issued on a stack). Safety checking can be
implemented mostly independent from the implementation details of the
stack (usage of internal data structures). There are as well different
ways of checking the safety. Therefore we say that safety checking is
orthogonal to the stack core implementation.</p></div>
<div class="paragraph"><p>With NX we can define stack-safety as a separate class using methods
with the same names as the implementations before, and "mix" this
behavior into classes or objects. The implementation of <tt>Safety</tt> in
stack under-runs and to issue error messages, when this happens.</p></div>
<div class="paragraph" id="xmp-class-safety"><div class="title">Listing 7: Class Safety</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Safety {

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Implement stack safety by defining an additional
</span>  <span class='nx-comment'># instance variable named "count" that keeps track of
</span>  <span class='nx-comment'># the number of stacked elements. The methods of
</span>  <span class='nx-comment'># this class have the same names and argument lists
</span>  <span class='nx-comment'># as the methods of Stack; these methods "shadow"
</span>  <span class='nx-comment'># the methods of class Stack.
</span>  <span class='nx-comment'>#
</span>
  <span class='nx-keyword'>:variable</span> count 0

  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> push {thing} {
    <span class='nx-keyword'>incr</span> :count
    <span class='nx-keyword'>next</span>
  }

  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> pop {} {
    <span class='nx-keyword'>if</span> {<span class='nx-variable'>${</span><span class='nx-variable'>:count}</span> == 0} then { <span class='nx-keyword'>error</span> <span class='nx-string'>"Stack empty!"</span> }
    <span class='nx-keyword'>incr</span> :count -1
    <span class='nx-keyword'>next</span>
  }
}</pre></td></tr></table></div></div>
<div class="paragraph"><p>Note that all the methods of the class <tt>Safety</tt> end with <tt>next</tt>.
This command is a primitive command of NX, which calls the
same-named method with the same argument list as the current
invocation.</p></div>
<div class="paragraph"><p>Assume we save the definition of the class <tt>Stack</tt> in a file named
<tt>Stack.tcl</tt> and the definition of the class <tt>Safety</tt> in a file named
<tt>Safety.tcl</tt> in the current directory. When we load the classes
<tt>Stack</tt> and <tt>Safety</tt> into the same script (see the terminal dialog in
e.g. a certain stack <tt>s2</tt> as a safe stack, while all other stacks
(such as <tt>s1</tt>) might be still "unsafe". This can be achieved via the
option <tt>-mixin</tt> at the object creation time (see line 9 in
option <tt>-mixin</tt> mixes the class <tt>Safety</tt> into the new instance <tt>s2</tt>.</p></div>
<div class="paragraph" id="xmp-using-class-safety"><div class="title">Listing 8: Using the Class Safety</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
</pre></td><td class='nx-body'><pre class='nx'>% <span class='nx-keyword'>package</span> <span class='nx-keyword'>require</span> nx
2.0
% <span class='nx-keyword'>source</span> Stack.tcl
::Stack
% <span class='nx-keyword'>source</span> Safety.tcl
::Safety
% Stack <span class='nx-keyword'>create</span> s1
::s1
% Stack <span class='nx-keyword'>create</span> s2 -mixin Safety
::s2
% s2 push a
a
% s2 pop
a
% s2 pop
Stack empty!

% s1 <span class='nx-keyword'>info</span> precedence
::Stack ::nx::Object

% s2 <span class='nx-keyword'>info</span> precedence
::Safety ::Stack ::nx::Object</pre></td></tr></table></div></div>
<div class="paragraph"><p>When the method <tt>push</tt> of <tt>s2</tt> is called, first the method of the
mixin class <tt>Safety</tt> will be invoked that increments the counter and
continues with <tt>next</tt> to call the shadowed method, here the method
<tt>push</tt> of the <tt>Stack</tt> implementation that actually pushes the item.
The same happens, when <tt>s2 pop</tt> is invoked, first the method of
<tt>Safety</tt> is called, then the method of the <tt>Stack</tt>. When the stack is
empty (the value of <tt>count</tt> reaches 0), and <tt>pop</tt> is invoked, the
mixin class <tt>Safety</tt> generates an error message (raises an exception),
and does not invoke the method of the <tt>Stack</tt>.</p></div>
<div class="paragraph"><p>The last two commands in <a href="#xmp-using-class-safety">Listing 8</a> use introspection to query for the objects
<tt>s1</tt> and <tt>s2</tt> in which order the involved classes are processed. This
order is called the <tt>precedence order</tt> and is obtained via <tt>info
precedence</tt>. We see that the mixin class <tt>Safety</tt> is only in use for
<tt>s2</tt>, and takes there precedence over <tt>Stack</tt>. The common root class
<tt>nx::Object</tt> is for both <tt>s1</tt> and <tt>s2</tt> the base class.</p></div>
<div class="imageblock" id="img-per-object-mixin" style="text-align:center;">
<div class="content">
<img src="per-object-mixin.png" alt="per-object-mixin.png" />
</div>
<div class="title">Figure 9. Per-object Mixin</div>
</div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>Note that the class <tt>Safety</tt> is only mixed into a single object (here
<tt>s2</tt>), therefore we refer to this case as a <em>per-object mixin</em>.
<a href="#img-per-object-mixin">Figure 9</a> shows the class
diagram, where the class <tt>Safety</tt> is used as a per-object mixin for
<tt>s2</tt>.</p></div>
<div class="paragraph"><p>The class <tt>Safety</tt> can be used as well in other ways, such as e.g. for
defining classes for safe stacks &lt;&lt;xmp-class-safestack,</p></div>
<div class="paragraph" id="xmp-class-safestack"><div class="title">Listing 10: Class SafeStack</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-comment'>#
</span><span class='nx-comment'># Create a safe stack class by using Stack and mixin
</span><span class='nx-comment'># Safety
</span><span class='nx-comment'>#
</span><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> SafeStack -superclass Stack -mixin Safety

SafeStack <span class='nx-keyword'>create</span> s3</pre></td></tr></table></div></div>
<div class="paragraph"><p>The difference to the case with the per-object mixin is that now,
<tt>Safety</tt> is mixed into the definition of <tt>SafeStack</tt>. Therefore, all
instances of the class <tt>SafeStack</tt> (here the instance <tt>s3</tt>) will be
using the safety definitions.
for this definition.</p></div>
<div class="imageblock" id="img-per-class-mixin" style="text-align:center;">
<div class="content">
<img src="per-class-mixin.png" alt="per-class-mixin.png" />
</div>
<div class="title">Figure 11. Per-class Mixin</div>
</div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>Note that we could use <tt>Safety</tt> as well as a per-class mixin on
<tt>Stack</tt>. In this case, all stacks would be safe stacks and we could
not provide a selective feature selection (which might be perfectly
fine).</p></div>
</div>
<div class="sect2">
<h3 id="_define_different_kinds_of_stacks">2.4. Define Different Kinds of Stacks</h3>
<div class="paragraph"><p>The definition of <tt>Stack</tt> is generic and allows all kind of elements
to be stacked. Suppose, we want to use the generic stack definition,
but a certain stack (say, stack <tt>s4</tt>) should be a stack for integers
only. This behavior can be achieved by the same means as introduced
already in <a href="#xmp-object-stack">Listing 5</a>, namely
object-specific methods.</p></div>
<div class="paragraph" id="xmp-object-integer-stack"><div class="title">Listing 12: Object Integer Stack</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
</pre></td><td class='nx-body'><pre class='nx'>Stack <span class='nx-keyword'>create</span> s4 {

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Create a stack with a object-specific method
</span>  <span class='nx-comment'># to check the type of entries
</span>  <span class='nx-comment'>#
</span>
  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> push {thing:integer} {
    <span class='nx-keyword'>next</span>
  }
}</pre></td></tr></table></div></div>
<div class="paragraph"><p>The program snippet in <a href="#xmp-object-integer-stack">Listing 12</a> defines an instance <tt>s4</tt> of the class
<tt>Stack</tt> and provides an object specific method for <tt>push</tt> to implement
an integer stack. The method <tt>pull</tt> is the same for the integer stack
as for all other stacks, so it will be reused as usual from the class
<tt>Stack</tt>. The object-specific method <tt>push</tt> of <tt>s4</tt> has a value
constraint in its argument list (<tt>thing:integer</tt>) that makes sure,
that only integers can be stacked. In case the argument is not an
integer, an exception will be raised. Of course, one could perform the
value constraint checking as well in the body of the method <tt>proc</tt> by
accepting an generic argument and by performing the test for the value
in the body of the method. In the case, the passed value is an
integer, the <tt>push</tt> method of <a href="#xmp-object-integer-stack">Listing 12</a> calls <tt>next</tt>, and therefore calls the
shadowed generic definition of <tt>push</tt> as provided by <tt>Stack</tt>.</p></div>
<div class="paragraph" id="xmp-class-integer-stack"><div class="title">Listing 13: Class IntegerStack</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> IntegerStack -superclass Stack {

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Create a Stack accepting only integers
</span>  <span class='nx-comment'>#
</span>
  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> push {thing:integer} {
    <span class='nx-keyword'>next</span>
  }
}</pre></td></tr></table></div></div>
<div class="paragraph"><p>An alternative approach is shown in
<a href="#xmp-class-integer-stack">Listing 13</a>, where the class
<tt>IntegerStack</tt> is defined, using the same method definition
as <tt>s4</tt>, this time on the class level.</p></div>
</div>
<div class="sect2">
<h3 id="_define_class_specific_methods">2.5. Define Class Specific Methods</h3>
<div class="paragraph"><p>In our previous examples we defined methods provided by classes
(applicable for their instances) and object-specific methods (methods
defined on objects, which are only applicable for these objects). In
this section, we introduce methods that are defined on classes. These
method are only applicable for the class objects. Such methods are
sometimes called <em>class methods</em> or <em>static methods</em>.</p></div>
<div class="paragraph"><p>In NX classes are objects with certain properties. The classes are
objects providing methods for instance and which are managing the
life-cycles of the objects (we will come to this point in later
sections in more detail). Since classes are objects, it is also
possible to define object-specific methods for the class
objects. However, since <tt>:method</tt> applied on classes defines methods
for instances, we have to use the method-modifier <tt>class</tt> to denote
methods to be applied on the class itself. Note that instances do not
inherit class methods. The methods defined on the class object are
actually exactly same as the object-specific methods shown in the
examples above.</p></div>
<div class="paragraph" id="xmp-stack2"><div class="title">Listing 14: Class Stack2</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Stack2 {

   <span class='nx-keyword'>:public</span> <span class='nx-keyword'>class</span> <span class='nx-keyword'>method</span> available_stacks {} {
      <span class='nx-keyword'>return</span> [<span class='nx-keyword'>llength</span> [<span class='nx-keyword'>:info</span> instances]]
   }

   <span class='nx-keyword'>:variable</span> things {}

   <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> push {thing} {
      <span class='nx-keyword'>set</span> :things [<span class='nx-keyword'>linsert</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 0 <span class='nx-variable'>$thing</span>]
      <span class='nx-keyword'>return</span> <span class='nx-variable'>$thing</span>
   }

   <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> pop {} {
      <span class='nx-keyword'>set</span> top [<span class='nx-keyword'>lindex</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 0]
      <span class='nx-keyword'>set</span> :things [<span class='nx-keyword'>lrange</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 1 end]
      <span class='nx-keyword'>return</span> <span class='nx-variable'>$top</span>
   }
}

Stack2 <span class='nx-keyword'>create</span> s1
Stack2 <span class='nx-keyword'>create</span> s2

<span class='nx-keyword'>puts</span> [Stack2 available_stacks]</pre></td></tr></table></div></div>
<div class="paragraph"><p>The class <tt>Stack2</tt> in <a href="#xmp-stack2">Listing 14</a> consists of the
earlier definition of the class <tt>Stack</tt> and is extended by the
class-specific method <tt>available_stacks</tt>, which returns the
current number of instances of the stack. The final command <tt>puts</tt>
(line 26) prints 2 to the console.</p></div>
<div class="imageblock" id="img-stack2" style="text-align:center;">
<div class="content">
<img src="stack2.png" alt="stack2.png" />
</div>
<div class="title">Figure 15. Stack2</div>
</div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>The class diagram in <a href="#img-stack2">Figure 15</a> shows the
diagrammatic representation of the class object-specific method
<tt>available_stacks</tt>.  Since every class is a specialization of the
common root class <tt>nx::Object</tt>, the common root class is often omitted
from the class diagrams, so it was omitted here as well in the diagram.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_basic_language_features_of_nx">3. Basic Language Features of NX</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_variables_and_properties">3.1. Variables and Properties</h3>
<div class="paragraph"><p>In general, NX does not need variable declarations. It allows to
create or modify variables on the fly by using for example the Tcl
commands <tt>set</tt> and <tt>unset</tt>. Depending on the variable name (or more
precisely, depending on the variable name&#8217;s prefix consisting of
colons <tt>:</tt>) a variable is either local to a method, or it is an
instance variable, or a global variable.  The rules are:</p></div>
<div class="ulist"><ul>
<li>
<p>
A variable without any colon prefix refers typically to a method
   scoped variable. Such a variable is created during the invocation
   of the method, and it is deleted, when the method ends.  In the
   example below, the variable <tt>a</tt> is method scoped.
</p>
</li>
<li>
<p>
A variable with a single colon prefix refers to an instance
    variable.  An instance variable is part of the object; when the
    object is destroyed, its instance variables are deleted as well. In the
    example below, the variable <tt>b</tt> is an instance variable.
</p>
</li>
<li>
<p>
A variable with two leading colons refers to a global variable. The
  lifespan of a globale variable ends when the variable is explicitly
  unset or the script terminates. Variables, which are placed in Tcl
  namespaces, are also global variables. In the example below, the
  variable <tt>c</tt> is a global variable.
</p>
</li>
</ul></div>
<div class="paragraph" id="xmp-var-resolver"><div class="title">Listing 16: Scopes of Variables</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Foo {

  <span class='nx-keyword'>:method</span> foo args {...}
    <span class='nx-comment'># "a" is a method scoped variable
</span>    <span class='nx-keyword'>set</span> a 1
    <span class='nx-comment'># "b" is an Instance variable
</span>    <span class='nx-keyword'>set</span> :b 2
    <span class='nx-comment'># "c" is a global variable/namespaced variable
</span>    <span class='nx-keyword'>set</span> ::c 3
  }
}</pre></td></tr></table></div></div>
<div class="paragraph"><p><a href="#xmp-var-resolver">Listing 16</a> shows a method <tt>foo</tt>
of some class <tt>Foo</tt> referring to differently scoped variables.</p></div>
<div class="sect3">
<h4 id="_properties_instance_variables_with_accessors">3.1.1. Properties: Instance Variables with Accessors</h4>
<div class="paragraph"><p>Generally, there is no need to define or declare instance variables in
NX. In some cases, however, a definition of instance variables is
useful. NX allows us to define instances variables as <em>properties</em> on
classes, which are inherited to subclasses. Furthermore, the
definition of properties can be used the check permissible values for
instance variables or to initialize instance variables from default
values during object initialization.</p></div>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>A <strong>property</strong> is a definition of an attribute (an instance variable)
with accessors. The property definition might as well carry
value-constraints and a default value.</p></div>
</div></div>
<div class="imageblock" id="img-person-student" style="text-align:center;">
<div class="content">
<img src="person-student.png" alt="person-student.png" />
</div>
<div class="title">Figure 17. Classes Person and Student</div>
</div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>The class diagram above defines the classes <tt>Person</tt> and
<tt>Student</tt>. For both classes, accessor methods are specified with the
same names as the attributes. (Note that we show the accessor methods
only in this example, we omit it in later ones). By defining
properties we can use the name of the attribute as method name to
access the attributes. The listing below shows an implementation of this
conceptual model in NX.</p></div>
<div class="paragraph" id="xmp-properties"><div class="title">Listing 18: Properties</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-comment'>#
</span><span class='nx-comment'># Define a class Person with properties "name"
</span><span class='nx-comment'># and "birthday"
</span><span class='nx-comment'>#
</span><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Person {
  <span class='nx-keyword'>:property</span> name:required
  <span class='nx-keyword'>:property</span> birthday
}

<span class='nx-comment'>#
</span><span class='nx-comment'># Define a class Student as specialization of Person
</span><span class='nx-comment'># with additional properties
</span><span class='nx-comment'>#
</span><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Student -superclass Person {
  <span class='nx-keyword'>:property</span> matnr:required
  <span class='nx-keyword'>:property</span> {oncampus:boolean true}
}

<span class='nx-comment'>#
</span><span class='nx-comment'># Create instances using object parameters
</span><span class='nx-comment'># for the initialization
</span><span class='nx-comment'>#
</span>Person <span class='nx-keyword'>create</span> p1 -name Bob
Student <span class='nx-keyword'>create</span> s1 -name Susan -matnr 4711

<span class='nx-comment'># Access property value via accessor method
</span><span class='nx-keyword'>puts</span> <span class='nx-string'>"The name of s1 is [s1 name]"</span></pre></td></tr></table></div></div>
<div class="paragraph"><p>By defining <tt>name</tt> and <tt>birthday</tt> as properties of <tt>Person</tt>, NX
provides automatically accessor methods with the same name.  The
accessors methods (or shortly called "accessors") provide read and
write access to the underlying instance variables. In our example, the
class <tt>Person</tt> has two methods implied by the <tt>property</tt> definition:
the method <tt>name</tt> and the method <tt>birthday</tt>.</p></div>
<div class="paragraph"><p>The class <tt>Student</tt> is defined as a specialization of <tt>Person</tt> with
two additional properties: <tt>matnr</tt> and <tt>oncampus</tt>. The property
<tt>matnr</tt> is required (it has to be provided, when an instance of this
class is created), and the property <tt>oncampus</tt> is boolean, and is per
default set to <tt>true</tt>. Note that the class <tt>Student</tt> inherits the
properties of <tt>Person</tt>. So, <tt>Student</tt> has four properties in total.</p></div>
<div class="paragraph"><p>The property definitions are also used to providing <tt>object
parameters</tt>. These are typically non-positional parameters, which are
used during object creation to supply values to the instance
variables. In our listing, we create an instance of <tt>Person</tt> using the
object parameter <tt>name</tt> and provide the value of <tt>Bob</tt> to the instance
variable <tt>name</tt>.  Similarly, we create an instance of <tt>Student</tt> using
the two object parameters <tt>name</tt> and <tt>matnr</tt>. Finally, we use the
accessor method <tt>name</tt> to obtain the value of the instance variable
<tt>name</tt> of object <tt>s1</tt>.</p></div>
</div>
<div class="sect3">
<h4 id="_instance_variables_without_accessors">3.1.2. Instance Variables without Accessors</h4>
<div class="paragraph"><p>To define instances variables with default values without accessors
the predefined method <tt>variable</tt> can be used. Such instance variables
are often used for e.g. keeping the internal state of an object.  The
usage of <tt>variable</tt> is in many respects similar to <tt>property</tt>. One
difference is, that <tt>property</tt> uses the same syntax as for method
parameters, whereas <tt>variable</tt> receives the default value as a separate
argument (similar to the <tt>variable</tt> command in Tcl). The introductory
Stack example in <a href="#xmp-class-stack">Listing 2</a> uses already
the method <tt>variable</tt>.</p></div>
<div class="paragraph" id="xmp-variable"><div class="title">Listing 19: Declaring Variables</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Base {
  <span class='nx-keyword'>:variable</span> x 1
  <span class='nx-comment'># ...
</span>}

<span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Derived -superclass Base {
  <span class='nx-keyword'>:variable</span> y 2
  <span class='nx-comment'># ...
</span>}

<span class='nx-comment'># Create instance of the class Derived
</span>Derived <span class='nx-keyword'>create</span> d1

<span class='nx-comment'># Object d1 has instance variables
</span><span class='nx-comment'># x == 1 and y == 2</span></pre></td></tr></table></div></div>
<div class="paragraph"><p>Note that the variable definitions are inherited in the same way as
properties. The example in <a href="#xmp-variable">Listing 19</a> shows a
class <tt>Derived</tt> that inherits from <tt>Base</tt>. When an instance <tt>d1</tt> is
created, it will contain the two instance variables <tt>x</tt> and <tt>y</tt>.</p></div>
<div class="paragraph" id="xmp-constructor"><div class="title">Listing 20: Setting Variables in the Constructor</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Base2 {
 <span class='nx-comment'># ...
</span> <span class='nx-keyword'>:method</span> <span class='nx-keyword'>init</span> {} {
   <span class='nx-keyword'>set</span> :x 1
   <span class='nx-comment'># ....
</span> }
}

<span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Derived2 -superclass Base2 {
 <span class='nx-comment'># ...
</span> <span class='nx-keyword'>:method</span> <span class='nx-keyword'>init</span> {} {
   <span class='nx-keyword'>set</span> :y 2
   <span class='nx-keyword'>next</span>
   <span class='nx-comment'># ....
</span> }
}

<span class='nx-comment'># Create instance of the class Derived2
</span>Derived2 <span class='nx-keyword'>create</span> d2</pre></td></tr></table></div></div>
<div class="paragraph"><p>In many other object oriented languages, the instance variables are
initialized solely by the constructor (similar to class <tt>Derived2</tt> in
<a href="#xmp-constructor">Listing 20</a>). This approach is certainly
also possible in NX. Note that the approach using constructors
requires an explicit method chaining between the constructors and is
less declarative than the approach in NX using <tt>property</tt> and <tt>variable</tt>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_method_definitions">3.2. Method Definitions</h3>
<div class="paragraph"><p>The basic building blocks of an object oriented program are object and
classes, which contain named pieces of code, the methods.</p></div>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p><strong>Methods</strong> are subroutines (pieces of code) associated with objects
and/or classes. A method has a name, receives optionally arguments
during invocation and returns a value.</p></div>
</div></div>
<div class="paragraph"><p>Plain Tcl provides subroutines, which are not associated with objects
or classes. Tcl distinguishes between +proc+s (scripted subroutines)
and  commands (system-languages implemented subroutines).</p></div>
<div class="paragraph"><p>Methods might have different scopes, defining, on which kind of
objects these methods are applicable to. These are described in more
detail later on. For the time being, we deal here with methods defined
on classes, which are applicable for the instance of these classes.</p></div>
<div class="sect3">
<h4 id="_scripted_methods">3.2.1. Scripted Methods</h4>
<div class="paragraph"><p>Since NX is a scripting language, most methods are most likely
scripted methods, in which the method body contains Tcl code.</p></div>
<div class="paragraph" id="xmp-fido1"><div class="title">Listing 21: Scripted method</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-comment'># Define a class
</span><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Dog {

  <span class='nx-comment'># Define a scripted method for the class
</span>  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> bark {} {
    <span class='nx-keyword'>puts</span> <span class='nx-string'>"[self] Bark, bark, bark."</span>
  }
}

<span class='nx-comment'># Create an instance of the class
</span>Dog <span class='nx-keyword'>create</span> fido

<span class='nx-comment'># The following line prints "::fido Bark, bark, bark."
</span>fido bark</pre></td></tr></table></div></div>
<div class="paragraph"><p>In the example above we create a class <tt>Dog</tt> with a scripted method
named <tt>bark</tt>. The method body defines the code, which is executed when
the method is invoked. In this example, the method <tt>bar</tt> prints out a
line on the terminal starting with the object name (this is determined
by the built in command <tt>self</tt>) followed by "Bark, bark, bark.".  This
method is defined on a class and applicable to instances of the class
(here the instance <tt>fido</tt>).</p></div>
</div>
<div class="sect3">
<h4 id="_c_implemented_methods">3.2.2. C-implemented Methods</h4>
<div class="paragraph"><p>Not all of the methods usable in NX are scripted methods; many
predefined methods are defined in the underlying system language,
which is typically C.  For example, in <a href="#xmp-fido1">Listing 21</a> we
used the method <tt>create</tt> to create the class <tt>Dog</tt> and to create the
dog instance <tt>fido</tt>. These methods are implemented in C in the next
scripting framework.</p></div>
<div class="paragraph"><p>C-implemented methods are not only provided by the underlying
framework but might be as well defined by application developers. This
is an advanced topic, not covered here. However, application developer
might reuse some generic C code to define their own C-implemented
methods. Such methods are for example <em>accessors</em>, <em>forwarders</em> and
<em>aliases</em>.</p></div>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>An <strong>accessor method</strong> is in most cases a C-implemented method that
accesses instance variables of an object. A call to an accessor
without arguments uses the accessor as a getter, obtaining the actual
value of the associated variable. A call to an accessor with an
argument uses it as a setter, setting the value of the associated
variable.</p></div>
</div></div>
<div class="paragraph"><p>Accessors have already been discussed in the section about properties,
in which the accessors were created automatically.</p></div>
<div class="paragraph" id="xmp-fido2"><div class="title">Listing 22: Accessor Methods</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Dog {
 <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> bark {} { <span class='nx-keyword'>puts</span> <span class='nx-string'>"[self] Bark, bark, bark."</span> }
 <span class='nx-keyword'>:method</span> <span class='nx-keyword'>init</span> {} { Tail <span class='nx-keyword'>create</span> [<span class='nx-keyword'>self</span>]::tail}
}

<span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Tail {
  <span class='nx-keyword'>:property</span> {length:double 5}
  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> wag {} {<span class='nx-keyword'>return</span> Joy}
}

<span class='nx-comment'># Create an instance of the class
</span>Dog <span class='nx-keyword'>create</span> fido

<span class='nx-comment'># Use the accessor "length" as a getter, to obtain the value
</span><span class='nx-comment'># of a property. The following call returns the length of the
</span><span class='nx-comment'># tail of fido
</span>fido::tail length

<span class='nx-comment'># Use the accessor "length" as a setter, to alter the value
</span><span class='nx-comment'># of a property. The following call changes the length of
</span><span class='nx-comment'># the tail of fido
</span>fido::tail length 10

<span class='nx-comment'># Proving an invalid values will raise an error
</span>fido::tail length <span class='nx-string'>"Hello"</span></pre></td></tr></table></div></div>
<div class="paragraph"><p><a href="#xmp-fido2">Listing 22</a> shows an extended example, where every dog
has a tail. The object <tt>tail</tt> is created as a subobject of the dog in
the constructor <tt>init</tt>. The subobject can be accessed by providing the
full name of the subobject <tt>fido::tail</tt>. The method <tt>length</tt> is an
C-implemented accessor, that enforces the value constraint (here a
floating point number, since length uses the value constraint
<tt>double</tt>).</p></div>
<div class="paragraph" id="xmp-fido3"><div class="title">Listing 23: Forwarder Methods</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Dog {
  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> bark {} { <span class='nx-keyword'>puts</span> <span class='nx-string'>"[self] Bark, bark, bark."</span> }
  <span class='nx-keyword'>:method</span> <span class='nx-keyword'>init</span> {} {
    Tail <span class='nx-keyword'>create</span> [<span class='nx-keyword'>self</span>]::tail
    <span class='nx-keyword'>:public</span> <span class='nx-keyword'>forward</span> wag [<span class='nx-keyword'>self</span>]::tail wag
  }
}

<span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Tail {
  <span class='nx-keyword'>:property</span> {length 5}
  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> wag {} {<span class='nx-keyword'>return</span> Joy}
}

<span class='nx-comment'># Create an instance of the class
</span>Dog <span class='nx-keyword'>create</span> fido

<span class='nx-comment'># The invocation of "fido wag" is delegated to "fido::tail wag".
</span><span class='nx-comment'># Therefore, the following method returns "Joy".
</span>fido wag</pre></td></tr></table></div></div>
<div class="paragraph"><p><a href="#xmp-fido3">Listing 23</a> again extends the example by adding a
forwarder named <tt>wag</tt> to the object (e.g. <tt>fido</tt>). The forwarder
redirects all calls of the form <tt>fido wag</tt> with arbitrary arguments to
the subobject <tt>fido::tail</tt>.</p></div>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>A <strong>forwarder method</strong> is a
C-implemented method that redirects an invocation for a certain method
to either a method of another object or to some other method of the
same object. Forwarding an invocation of a method to some other
object is a means of delegation.</p></div>
</div></div>
<div class="paragraph"><p>The functionality of the forwarder can just as well be implemented as
a scripted method, but for the most common cases, the forward
implementation is more efficient, and the <tt>forward</tt> method expresses
the intention of the developer.</p></div>
<div class="paragraph"><p>The method <tt>forwarder</tt> has several options to change e.g. the order of
the arguments, or to substitute certain patterns in the argument list
etc. This will be described in later sections.</p></div>
</div>
<div class="sect3">
<h4 id="_method_aliases">3.2.3. Method-Aliases</h4>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>An <strong>alias method</strong> is a means to register either an existing method,
or a Tcl proc, or a Tcl command as a method with the provided
name on a class or object.</p></div>
</div></div>
<div class="paragraph"><p>In some way, the method alias is a restricted form of a forwarder,
though it does not support delegation to different objects or argument
reordering. The advantage of the method alias compared to a forwarder
is that it has close to zero overhead, especially for aliasing
c-implemented methods.</p></div>
<div class="paragraph" id="xmp-fido4"><div class="title">Listing 24: Method-Alias</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Dog {
  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> bark {} { <span class='nx-keyword'>puts</span> <span class='nx-string'>"[self] Bark, bark, bark."</span> }

  <span class='nx-comment'># Define a public alias for the method "bark"
</span>  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>alias</span> warn [<span class='nx-keyword'>:info</span> <span class='nx-keyword'>method</span> handle bark]
  <span class='nx-comment'># ...
</span>}

<span class='nx-comment'># Create an instance of the class
</span>Dog <span class='nx-keyword'>create</span> fido

<span class='nx-comment'># The following line prints "::fido Bark, bark, bark."
</span>fido warn</pre></td></tr></table></div></div>
<div class="paragraph"><p><a href="#xmp-fido4">Listing 24</a> extends the last example by defining an
alias for the method "bark". The example only shows the bare
mechanism. In general, method aliases are very powerful means for
reusing pre-existing functionality. The full object system of NX and
XOTcl2 is built from aliases, reusing functionality provided by the
next scripting framework under different names. Method aliases
are as well a means for implementing traits in NX.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_method_protection">3.3. Method Protection</h3>
<div class="paragraph"><p>All kinds of methods might have different kind of protections in NX.
The call-protection defines from which calling context methods might
be called. The Next Scripting Framework supports as well redefinition
protection for methods.</p></div>
<div class="paragraph"><p>NX distinguished between <em>public</em>, <em>protected</em> and <em>private</em> methods,
where the default call-protection is "protected".</p></div>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>A <strong>public</strong> method can be called from every context. A <strong>protected</strong>
method can only be invoked from the same object. A <strong>private</strong> method
can only be invoked from methods defined on the same entity
(defined on the same class or on the same object) via the invocation
with the local flag (i.e. "<tt>: -local</tt>").</p></div>
</div></div>
<div class="paragraph"><p>All kind of method protections are applicable for all kind of methods,
either scripted or C-implemented.</p></div>
<div class="paragraph"><p>The distinction between public and protected leads to interfaces for
classes and objects. Public methods are intended for consumers of
these entities. Public methods define the intended ways of providing
methods for external usages (usages, from other objects or
classes). Protected methods are intended for the implementor of the
class or subclasses and not for public usage. The distinction between
protected and public reduces the coupling between consumers and the
implementation, and offers more flexibility to the developer.</p></div>
<div class="paragraph" id="xmp-protected-method"><div class="title">Listing 25: Protected Methods</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Foo {

  <span class='nx-comment'># Define a public method
</span>  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> foo {} {
    <span class='nx-comment'># ....
</span>    <span class='nx-keyword'>return</span> [:helper]
  }

  <span class='nx-comment'># Define a protected method
</span>  <span class='nx-keyword'>:method</span> helper {} {
     <span class='nx-keyword'>return</span> 1
  }
}

<span class='nx-comment'># Create an instance of the class:
</span>Foo <span class='nx-keyword'>create</span> f1

<span class='nx-comment'># The invocation of the public method "foo" returns 1
</span>f1 foo

<span class='nx-comment'># The invocation of the protected method "helper" raises an error:
</span>f1 helper</pre></td></tr></table></div></div>
<div class="paragraph"><p>The example above uses <tt>:protected method helper &#8230;</tt>. We could have
used here as well <tt>:method helper &#8230;</tt>, since the default method
call-protection is already protected.</p></div>
<div class="paragraph"><p>The method call-protection of <tt>private</tt> goes one step further and
helps to hide implementation details also for implementors of
subclasses. Private methods are a means for avoiding unanticipated name
clashes. Consider the following example:</p></div>
<div class="paragraph" id="xmp-private-method"><div class="title">Listing 26: Private Methods</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Base {
  <span class='nx-keyword'>:private</span> <span class='nx-keyword'>method</span> helper {a b} {<span class='nx-keyword'>expr</span> {<span class='nx-variable'>$a</span> + <span class='nx-variable'>$b</span>}}
  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> foo     {a b} {: -local helper <span class='nx-variable'>$a</span> <span class='nx-variable'>$b</span>}
}

<span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Sub -superclass Base {
  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> bar     {a b} {: -local helper <span class='nx-variable'>$a</span> <span class='nx-variable'>$b</span>}
  <span class='nx-keyword'>:private</span> <span class='nx-keyword'>method</span> helper {a b} {<span class='nx-keyword'>expr</span> {<span class='nx-variable'>$a</span> * <span class='nx-variable'>$b</span>}}
  <span class='nx-keyword'>:create</span> s1
}

s1 foo 3 4     ;<span class='nx-comment'># returns 7
</span>s1 bar 3 4     ;<span class='nx-comment'># returns 12
</span>s1 helper 3 4  ;<span class='nx-comment'># raises error: unable to dispatch method helper</span></pre></td></tr></table></div></div>
<div class="paragraph"><p>The base class implements a public method <tt>foo</tt> using the helper
method named <tt>helper</tt>. The derived class implements a as well a public
method <tt>bar</tt>, which is also using a helper method named <tt>helper</tt>. When
an instance <tt>s1</tt> is created from the derived class, the method <tt>foo</tt>
is invoked which uses in turn the private method of the base
class. Therefore, the invocation <tt>s1 foo 3 4</tt> returns its sum. If
the <tt>local</tt> flag had not beed used in helper, <tt>s1</tt> would
have tried to call the helper of <tt>Sub</tt>, which would be incorrect. For
all other purposes, the private methods are "invisible" in all
situations, e.g., when mixins are used, or within the <tt>next</tt>-path, etc.</p></div>
<div class="paragraph"><p>By using the <tt>local</tt> flag for the invocation it is possible to call
only the local definition of the method. If we would call the method
as usual, the resolution order would be the same as usual, starting
with filters, mixins, per-object methods and the full intrinsic class
hierarchy.</p></div>
</div>
<div class="sect2">
<h3 id="_applicability_of_methods">3.4. Applicability of Methods</h3>
<div class="paragraph"><p>As defined above, a method is a subroutine defined on an object or
class. This object (or class) contains the method. If the object (or
class) is deleted, the contained methods will be deleted as well.</p></div>
<div class="sect3">
<h4 id="_instance_methods">3.4.1. Instance Methods</h4>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>Typically, methods are defined on a class, and the methods defined on the
class are applicable to the instances (direct or indirect) of this
class. These methods are called <strong>instance methods</strong>.</p></div>
</div></div>
<div class="paragraph"><p>In the following example method, <tt>foo</tt> is an instance method defined
on class <tt>C</tt>.</p></div>
<div class="paragraph" id="xmp-instance-applicable"><div class="title">Listing 27: Methods applicable for instances</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> C {
  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> foo {} {<span class='nx-keyword'>return</span> 1}
  <span class='nx-keyword'>:create</span> c1
}

<span class='nx-comment'># Method "foo" is defined on class "C"
</span><span class='nx-comment'># and applicable to the instances of "C"
</span>c1 foo</pre></td></tr></table></div></div>
<div class="paragraph"><p>There are many programming languages that only allow these types of methods.
However, NX also allows methods to be defined on objects.</p></div>
</div>
<div class="sect3">
<h4 id="_object_methods">3.4.2. Object Methods</h4>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>Methods defined on objects are <strong>per-object methods</strong>. Per-object
methods are only applicable on the object, on which they are defined.
Per-object methods cannot be inherited from other objects.</p></div>
</div></div>
<div class="paragraph"><p>The following example defines an object specific method <tt>bar</tt> on the
instance <tt>c1</tt> of class <tt>C</tt>, and as well as the object specific method
<tt>baz</tt> defined on the object <tt>o1</tt>. An object-specific method is defined
simply by defining the method on an object.</p></div>
<div class="paragraph"><p>Note that we can define a per-object method that shadows (redefines)
for this object an intrinsic instance method.</p></div>
<div class="paragraph" id="xmp-object-applicable1"><div class="title">Listing 28: Per-object Method</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> C {
  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> foo {} {<span class='nx-keyword'>return</span> 1}
  <span class='nx-keyword'>:create</span> c1 {
     <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> foo {} {<span class='nx-keyword'>return</span> 2}
     <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> bar {} {<span class='nx-keyword'>return</span> 3}
  }
}

<span class='nx-comment'># Method "bar" is an object specific method of "c1"
</span>c1 bar

<span class='nx-comment'># object-specific method "foo" returns 2
</span>c1 foo

<span class='nx-comment'># Method "baz" is an object specific method of "o1"
</span><span class='nx-keyword'>nx::Object</span> <span class='nx-keyword'>create</span> o1 {
  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> baz {} {<span class='nx-keyword'>return</span> 4}
}
o1 baz</pre></td></tr></table></div></div>
</div>
<div class="sect3">
<h4 id="_class_methods">3.4.3. Class Methods</h4>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>A <strong>class method</strong> is a method defined on a class, which is only
applicable to the class object itself. The class method is a
per-object method of the class object.</p></div>
</div></div>
<div class="paragraph"><p>In NX, all classes are objects. Classes are in NX special kind of
objects that have e.g. the ability to create instances and to provide
methods for the instances. Classes manage their instances. The general
method set for classes is defined on the meta-classes (more about
this later).</p></div>
<div class="paragraph"><p>The following example defines a public class method <tt>bar</tt> on class
<tt>C</tt>. The class method is specified by using the modifier <tt>class</tt> in
front of <tt>method</tt> in the method definition command.</p></div>
<div class="paragraph" id="xmp-object-applicable2"><div class="title">Listing 29: Class Methods</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> C {
  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Define a class method "bar" and an instance
</span>  <span class='nx-comment'># method "foo"
</span>  <span class='nx-comment'>#
</span>  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>class</span> <span class='nx-keyword'>method</span> bar {} {<span class='nx-keyword'>return</span> 2}
  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> foo {} {<span class='nx-keyword'>return</span> 1}

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Create an instance of the current class
</span>  <span class='nx-comment'>#
</span>  <span class='nx-keyword'>:create</span> c1
}

<span class='nx-comment'># Method "bar" is a class method of class "C"
</span><span class='nx-comment'># therefore applicable on the class object "C"
</span>C bar

<span class='nx-comment'># Method "foo" is an instance method of "C"
</span><span class='nx-comment'># therefore applicable on instance "c1"
</span>c1 foo

<span class='nx-comment'># When trying to invoke the class method on the
</span><span class='nx-comment'># instance, an error will be raised.
</span>c1 bar</pre></td></tr></table></div></div>
<div class="paragraph"><p>In some other object oriented programming languages, class methods
are called "static methods".</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_ensemble_methods">3.5. Ensemble Methods</h3>
<div class="paragraph"><p>NX provides "ensemble methods" as a means to structure the method name
space and to group related methods. Ensemble methods are similar in
concept to Tcl&#8217;s ensemble commands.</p></div>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>An <strong>ensemble method</strong> is a form of a hierarchical method consisting of
a container method and sub-methods. The first argument of the
container method is interpreted as a selector (the sub-method). Every
sub-method can be an container method as well.</p></div>
</div></div>
<div class="paragraph"><p>Ensemble methods provide a means to group related commands together,
and they are extensible in various ways. It is possible to add
sub-methods at any time to existing ensembles. Furthermore, it is
possible to extend ensemble methods via mixin classes.</p></div>
<div class="paragraph"><p>The following example defines an ensemble method for <tt>string</tt>. An
ensemble method is defined when the provide method name contains a
space.</p></div>
<div class="paragraph" id="xmp-ensemble-methods"><div class="title">Listing 30: Ensemble Method</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> C {

    <span class='nx-comment'># Define an ensemble method "string" with sub-methods
</span>    <span class='nx-comment'># "length", "tolower" and "info"
</span>
    <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> <span class='nx-string'>"string length"</span>  {x} {....}
    <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> <span class='nx-string'>"string tolower"</span> {x} {...}
    <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> <span class='nx-string'>"string info"</span> {x} {...}
    ...
    <span class='nx-keyword'>:create</span> c1
}

<span class='nx-comment'># Invoke the ensemble method
</span>c1 <span class='nx-keyword'>string</span> length <span class='nx-string'>"hello world"</span></pre></td></tr></table></div></div>
</div>
<div class="sect2">
<h3 id="_method_resolution">3.6. Method Resolution</h3>
<div class="paragraph"><p>When a method is invoked, the applicable method is searched in the
following order:</p></div>
Per-object Mixins -> Per-class Mixins -> Object -> Intrinsic Class Hierarchy
<div class="paragraph"><p>In the case, no mixins are involved, first the object is searched for
a per-object method with the given name, and then the class hierarchy
of the object. The method can be defined multiple times on the search
path, so some of these method definitions might be <em>shadowed</em> by the
more specific definitions.</p></div>
<div class="paragraph" id="xmp-method-resolution"><div class="title">Listing 31: Method Resolution with Intrinsic Classes</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> C {
  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> foo {} { <span class='nx-keyword'>return</span> <span class='nx-string'>"C foo: [next]"</span>}
}

<span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> D -superclass C {

  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> foo {} { <span class='nx-keyword'>return</span> <span class='nx-string'>"D foo: [next]"</span>}

   <span class='nx-keyword'>:create</span> d1 {
     <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> foo {} { <span class='nx-keyword'>return</span> <span class='nx-string'>"d1 foo: [next]"</span>}
   }
}

<span class='nx-comment'># Invoke the method foo
</span>d1 foo
<span class='nx-comment'># result: "d1 foo: D foo: C foo: "
</span>
<span class='nx-comment'># Query the precedence order from NX via introspection
</span>d1 <span class='nx-keyword'>info</span> precedence
<span class='nx-comment'># result: "::D ::C ::nx::Object"</span></pre></td></tr></table></div></div>
<div class="paragraph"><p>Consider the example in
<tt>foo</tt> is invoked on object <tt>d1</tt>, the per-object method has the highest
precedence and is therefore invoked. The per-object methods shadows
the same-named methods in the class hierarchy, namely the method <tt>foo</tt>
of class <tt>D</tt> and the method <tt>foo</tt> of class <tt>C</tt>. The shadowed methods
can be still invoked, either via the primitive <tt>next</tt> or via method
handles (we used already method handles in the section about method
aliases). In the example above, <tt>next</tt> calls the shadowed method and
add their results to the results of every method. So, the final result
contains parts from <tt>d1</tt>, <tt>D</tt> and <tt>C</tt>. Note, that the topmost <tt>next</tt>
in method <tt>foo</tt> of class <tt>C</tt> shadows no method <tt>foo</tt> and simply
returns empty (and not an error message).</p></div>
<div class="paragraph"><p>The introspection method <tt>info precedence</tt> provides information about
the order, in which classes processed during method resolution.</p></div>
<div class="paragraph" id="xmp-method-resolution2"><div class="title">Listing 32: Method Resolution with Mixin Classes</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> M1 {
  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> foo {} { <span class='nx-keyword'>return</span> <span class='nx-string'>"M1 foo: [next]"</span>}
}
<span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> M2 {
  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> foo {} { <span class='nx-keyword'>return</span> <span class='nx-string'>"M2 foo: [next]"</span>}
}

<span class='nx-comment'>#
</span><span class='nx-comment'># "d1" is created based on the definitions of the last example
</span><span class='nx-comment'>#
</span><span class='nx-comment'># Add the methods from "M1" as per-object mixin to "d1"
</span>d1 <span class='nx-keyword'>mixin</span> M1

<span class='nx-comment'>#
</span><span class='nx-comment'># Add the methods from "M2" as per-class mixin to class "C"
</span>C <span class='nx-keyword'>mixin</span> M2

<span class='nx-comment'># Invoke the method foo
</span>d1 foo
<span class='nx-comment'># result: "M1 foo: M2 foo: d1 foo: D foo: C foo: "
</span>
<span class='nx-comment'># Query the precedence order from NX via introspection
</span>d1 <span class='nx-keyword'>info</span> precedence
<span class='nx-comment'># result: "::M1 ::M2 ::D ::C ::nx::Object"</span></pre></td></tr></table></div></div>
<div class="paragraph"><p>an extension of the previous example. We define here two additional
classes <tt>M1</tt> and <tt>M2</tt> which are used as per-object and per-class
mixins.  Both classes define the method <tt>foo</tt>, these methods shadow
the definitions of the intrinsic class hierarchy. Therefore an
invocation of <tt>foo</tt> on object <tt>d1</tt> causes first an invocation of
method in the per-object mixin.</p></div>
<div class="paragraph" id="xmp-method-resolution3"><div class="title">Listing 33: Method Invocation Flags</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-comment'>#
</span><span class='nx-comment'># "d1" is created based on the definitions of the last two examples,
</span><span class='nx-comment'># the mixins "M1" and "M2" are registered.
</span><span class='nx-comment'>#
</span><span class='nx-comment'># Define a public per-object method "bar", which calls the method
</span><span class='nx-comment'># "foo" which various invocation options:
</span><span class='nx-comment'>#
</span>d1 <span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> bar {} {
   <span class='nx-keyword'>puts</span> [:foo]
   <span class='nx-keyword'>puts</span> [: -local foo]
   <span class='nx-keyword'>puts</span> [: -intrinsic foo]
   <span class='nx-keyword'>puts</span> [: -system foo]
}

<span class='nx-comment'># Invoke the method "bar"
</span>d1 bar</pre></td></tr></table></div></div>
<div class="paragraph"><p>In the first line of the body of method <tt>bar</tt>, the method <tt>foo</tt> is
called as usual with an implicit receiver, which defaults to the
current object (therefore, the call is equivalent to <tt>d1 foo</tt>). The
next three calls show how to provide flags that influence the method
resolution. The flags can be provided between the colon and the method
name. These flags are used rather seldomly but can be helpful in some
situations.</p></div>
<div class="paragraph"><p>The invocation flag <tt>-local</tt> means that the method has to be resolved
from the same place, where the current method is defined. Since the
current method is defined as a per-object method, <tt>foo</tt> is resolved as
a per-object method. The effect is that the mixin definitions are
ignored. The invocation flag <tt>-local</tt> was already introduced int the
section about method protection, where it was used to call <em>private</em>
methods.</p></div>
<div class="paragraph"><p>The invocation flag <tt>-intrinsic</tt> means that the method has to be resolved
from the intrinsic definitions, meaning simply without mixins. The
effect is here the same as with the invocation flag <tt>-local</tt>.</p></div>
<div class="paragraph"><p>The invocation flag <tt>-system</tt> means that the method has to be resolved
from basic - typically predefined - classes of the object system. This
can be useful, when script overloads system methods, but still want to
call the shadowed methods from the base classes. In our case, we have
no definitions of <tt>foo</tt> on the base clases, therefore an error message
is returned.</p></div>
<div class="paragraph"><p></p></div>
<div class="listingblock">
<div class="content">
<pre><tt>   M1 foo: M2 foo: d1 foo: D foo: C foo:
   d1 foo: D foo: C foo:
   d1 foo: D foo: C foo:
   ::d1: unable to dispatch method 'foo'</tt></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_parameters">3.7. Parameters</h3>
<div class="paragraph"><p>NX provides a generalized mechanism for passing values to either
methods (we refer to these as <em>method parameters</em>) or to objects
(these are called <em>object parameters</em>). Both kind of parameters
might have different features, such as:</p></div>
<div class="ulist"><ul>
<li>
<p>
Positional and non-positional parameters
</p>
</li>
<li>
<p>
Required and non-required parameters
</p>
</li>
<li>
<p>
Default values for parameters
</p>
</li>
<li>
<p>
Value-checking for parameters
</p>
</li>
<li>
<p>
Multiplicity of parameters
</p>
</li>
</ul></div>
<div class="paragraph"><p>TODO: complete list above and provide a short summary of the section</p></div>
<div class="paragraph"><p>Before we discuss method and object parameters in more detail, we
describe the parameter features in the subsequent sections based on
method parameters.</p></div>
<div class="sect3">
<h4 id="_positional_and_non_positional_parameters">3.7.1. Positional and Non-Positional Parameters</h4>
<div class="paragraph"><p>If the position of a parameter in the list of formal arguments
(e.g. passed to a function) is significant for its meaning, this is a
<em>positional</em> parameter. If the meaning of the parameter is independent
of its position, this is a <em>non-positional</em> parameter. When we call a
method with positional parameters, the meaning of the parameters (the
association with the argument in the argument list of the method) is
determined by its position. When we call a method with non-positional
parameters, their meaning is determined via a name passed with the
argument during invocation.</p></div>
<div class="paragraph" id="xmp-posnonpos"><div class="title">Listing 34: Positional and Non-Positional Method Parameters</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Object</span> <span class='nx-keyword'>create</span> o1 {

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Method foo has positional parameters:
</span>  <span class='nx-comment'>#
</span>  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> foo {x y} {
    <span class='nx-keyword'>puts</span> <span class='nx-string'>"x=$x y=$y"</span>
  }

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Method bar has non-positional parameters:
</span>  <span class='nx-comment'>#
</span>  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> bar {-x -y} {
    <span class='nx-keyword'>puts</span> <span class='nx-string'>"x=$x y=$y"</span>
  }

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Method baz has non-positional and
</span>  <span class='nx-comment'># positional parameters:
</span>  <span class='nx-comment'>#
</span>  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> baz {-x -y a} {
    <span class='nx-keyword'>puts</span> <span class='nx-string'>"x? [info exists x] y? [info exists y] a=$a"</span>
  }
}

<span class='nx-comment'># invoke foo (positional parameters)
</span>o1 foo 1 2

<span class='nx-comment'># invoke bar (non-positional parameters)
</span>o1 bar -y 3 -x 1
o1 bar -x 1 -y 3

<span class='nx-comment'># invoke baz (positional and non-positional parameters)
</span>o1 baz -x 1 100
o1 baz 200
o1 baz -- -y</pre></td></tr></table></div></div>
<div class="paragraph"><p>Consider the example in <a href="#xmp-posnonpos">Listing 34</a>. The method
<tt>foo</tt> has the argument list <tt>x y</tt>. This means that the first argument
is passed in an invocation like <tt>o1 foo 1 2</tt> to <tt>x</tt> (here, the value
<tt>1</tt>), and the second argument is passed to <tt>y</tt> (here the value <tt>2</tt>).
Method <tt>bar</tt> has in contrary just with non-positional arguments. Here
we pass the names of the parameter together with the values. In the
invocation <tt>o1 bar -y 3 -x 1</tt> the names of the parameters are prefixed
with a dash ("-"). No matter whether in which order we write the
non-positional parameters in the invocation (see line 30 and 31 in
<a href="#xmp-posnonpos">Listing 34</a>) in both cases the variables <tt>x</tt>
and <tt>y</tt> in the body of the method <tt>bar</tt> get the same values assigned
(<tt>x</tt> becomes <tt>1</tt>, <tt>y</tt> becomes <tt>3</tt>).</p></div>
<div class="paragraph"><p>It is certainly possible to combine positional and non-positional
arguments. Method <tt>baz</tt> provides two non-positional parameter (<tt>-y</tt>
and <tt>-y</tt>) and one positional parameter (namely <tt>a</tt>). The invocation in
line 34 passes the value of <tt>1</tt> to <tt>x</tt> and the value of <tt>100</tt> to <tt>a</tt>.
There is no value passed to <tt>y</tt>, therefore value of <tt>y</tt> will be
undefined in the body of <tt>baz</tt>, <tt>info exists y</tt> checks for the
existence of the variable <tt>y</tt> and returns <tt>0</tt>.</p></div>
<div class="paragraph"><p>The invocation in line 35 passes only a value to the positional
parameter. A more tricky case is in line 36, where we want to pass
<tt>-y</tt> as a value to the positional parameter <tt>a</tt>. The case is more
tricky since syntactically the argument parser might consider <tt>-y</tt> as
the name of one of the non-positional parameter. Therefore we use <tt>--</tt>
(double dash) to indicate the end of the block of the non-positional
parameters and therefore the value of <tt>-y</tt> is passed to <tt>a</tt>.</p></div>
</div>
<div class="sect3">
<h4 id="_optional_and_required_parameters">3.7.2. Optional and Required Parameters</h4>
<div class="paragraph"><p>Per default positional parameters are required, and non-positional
parameters are optional (they can be left out). By using parameter
options, we can as well define positional parameters, which are
optional, and non-positional parameters, which are required.</p></div>
<div class="paragraph" id="xmp-optional-req"><div class="title">Listing 35: Optional and Required Method Parameters</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Object</span> <span class='nx-keyword'>create</span> o2 {

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Method foo has one required and one optional
</span>  <span class='nx-comment'># positional parameter:
</span>  <span class='nx-comment'>#
</span>  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> foo {x:required y:optional} {
    <span class='nx-keyword'>puts</span> <span class='nx-string'>"x=$x y? [info exists y]"</span>
  }

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Method bar has one required and one optional
</span>  <span class='nx-comment'># non-positional parameter:
</span>  <span class='nx-comment'>#
</span>  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> bar {-x:required -y:optional} {
    <span class='nx-keyword'>puts</span> <span class='nx-string'>"x=$x y? [info exists y]"</span>
  }
}

<span class='nx-comment'># invoke foo (one optional positional parameter is missing)
</span>o2 foo 1</pre></td></tr></table></div></div>
<div class="paragraph"><p>The example in <a href="#xmp-optional-req">Listing 35</a> defined method <tt>foo</tt>
with one required and one optional positional parameter. For this
purpose we use the parameter options <tt>required</tt> and <tt>optional</tt>. The
parameter options are separated from the parameter name by a colon. If
there are multiple parameter options, these are separated by commas
(we show this in later examples).</p></div>
<div class="paragraph"><p>The parameter definition <tt>x:required</tt> for method <tt>foo</tt> is equivalent
to <tt>x</tt> without any parameter options (see e.g. previous example),
since positional parameters are per default required. The invocation
in line 21 of <a href="#xmp-optional-req">Listing 35</a> will lead to an
undefined variable <tt>y</tt> in method <tt>foo</tt>, because no value us passed to
the optional parameter. Note that only trailing positional parameters might be
optional. If we would call method <tt>foo</tt> of <a href="#xmp-posnonpos">Listing 34</a> with only one argument, the system would raise an
exception.</p></div>
<div class="paragraph"><p>Similarly, we define method <tt>bar</tt> in <a href="#xmp-optional-req">Listing 35</a> with one required and one optional non-positional
parameter. The parameter definition <tt>-y:optional</tt> is equivalent to
<tt>-y</tt>, since non-positional parameter are per default optional.
However, the non-positional parameter <tt>-x:required</tt> is required. If we
invoke <tt>bar</tt> without it, the system will raise an exception.</p></div>
</div>
<div class="sect3">
<h4 id="_default_values_for_parameters">3.7.3. Default Values for Parameters</h4>
<div class="paragraph"><p>Optional parameters might have a default value, which will be used,
when not value is provided for this parameter.  Default values can be
specified for positional and non-positional parameters.</p></div>
<div class="paragraph" id="xmp-default-value"><div class="title">Listing 36: Method Parameters with Default Values</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Object</span> <span class='nx-keyword'>create</span> o3 {

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Positional parameter with default value:
</span>  <span class='nx-comment'>#
</span>  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> foo {x:required {y 101}} {
    <span class='nx-keyword'>puts</span> <span class='nx-string'>"x=$x y? [info exists y]"</span>
  }

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Non-positional parameter with default value:
</span>  <span class='nx-comment'>#
</span>  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> bar {{-x 10} {-y 20}} {
    <span class='nx-keyword'>puts</span> <span class='nx-string'>"x=$x y? [info exists y]"</span>
  }
}

<span class='nx-comment'># use default values
</span>o3 foo
o3 bar</pre></td></tr></table></div></div>
<div class="paragraph"><p>In order to define a default value, the parameter specification must
be of the form of a 2 element list, where the second argument is the
default value. See for an example in
<a href="#xmp-default-value">Listing 36</a>.</p></div>
</div>
<div class="sect3">
<h4 id="_value_constraints">3.7.4. Value Constraints</h4>
<div class="paragraph"><p>NX provides value constraints for all kind of parameters. By
specifying value constraints a developer can restrict the permissible
values for a parameter and document the expected values in the source
code. Value checking in NX is conditional, it can be turned on or off
in general or on a per-usage level (more about this later). The same
mechanisms can be used not only for input value checking, but as well
for return value checking (we will address this point as well later).</p></div>
<div class="sect4">
<h5 id="_built_in_value_constraints">Built-in Value Constraints</h5>
<div class="paragraph"><p>NX comes with a set of built-in value constraints, which can be
extended on the scripting level. The built-in checkers are either the
native checkers provided directly by the Next Scripting Framework (the
most efficient checkers) or the value checkers provided by Tcl through
<tt>string is &#8230;</tt>. The built-in checkers have as well the advantage that
they can be used also at any time during bootstrap of an object
system, at a time, when e.g. no objects or methods are defined. The
same checkers are used as well for all C-implemented primitives of NX
and the Next Scripting Framework.</p></div>
<div class="imageblock" id="img-value-checkers" style="text-align:center;">
<div class="content">
<img src="value-checkers.png" alt="value-checkers.png" />
</div>
<div class="title">Figure 37. General Applicable Value Checkers in NX</div>
</div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p><a href="#img-value-checkers">Figure 37</a> shows the built-in
general applicable value checkers available in NX, which can be used
for all method and object parameters. In the next step, we show how to
use these value-checkers for checking permissible values for method
parameters. Then we will show, how to provide more detailed value
constraints.</p></div>
<div class="paragraph" id="xmp-value-check"><div class="title">Listing 38: Method Parameters with Value Constraints</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Object</span> <span class='nx-keyword'>create</span> o4 {

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Positional parameter with value constraints:
</span>  <span class='nx-comment'>#
</span>  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> foo {x:integer o:object,optional} {
    <span class='nx-keyword'>puts</span> <span class='nx-string'>"x=$x o? [info exists o]"</span>
  }

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Non-positional parameter with value constraints:
</span>  <span class='nx-comment'>#
</span>  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> bar {{-x:integer 10} {-verbose:boolean false}} {
    <span class='nx-keyword'>puts</span> <span class='nx-string'>"x=$x y=$y"</span>
  }
}

<span class='nx-comment'># The following invocation raises an exception
</span>o4 foo a</pre></td></tr></table></div></div>
<div class="paragraph"><p>Value contraints are specified as parameter options in the parameter
specifications. The parameter specification <tt>x:integer</tt> defines <tt>x</tt> as
a required positional parmeter which value is constraint to an
integer. The parameter specification <tt>o:object,optional</tt> shows how to
combine multiple parameter options. The parameter <tt>o</tt> is an optional
positional parameter, its value must be an object (see
<a href="#xmp-value-check">Listing 38</a>). Value constraints are
specified exactly the same way for non-positional parameters (see
method <tt>bar</tt> in <a href="#xmp-value-check">Listing 38</a>).</p></div>
<div class="paragraph" id="xmp-check-parameterized"><div class="title">Listing 39: Parameterized Value Constraints</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-comment'>#
</span><span class='nx-comment'># Create classes for Person and Project
</span><span class='nx-comment'>#
</span><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Person
<span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Project

<span class='nx-keyword'>nx::Object</span> <span class='nx-keyword'>create</span> o5 {
  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Parameterized value constraints
</span>  <span class='nx-comment'>#
</span>  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> work {
     -person:object,type=Person
     -project:object,type=Project
   } {
    <span class='nx-comment'># ...
</span>  }
}

<span class='nx-comment'>#
</span><span class='nx-comment'># Create a Person and a Project instance
</span><span class='nx-comment'>#
</span>Person <span class='nx-keyword'>create</span> gustaf
Project <span class='nx-keyword'>create</span> nx

<span class='nx-comment'>#
</span><span class='nx-comment'># Use method with value constraints
</span><span class='nx-comment'>#
</span>o5 work -person gustaf -project nx</pre></td></tr></table></div></div>
<div class="paragraph"><p>The native checkers <tt>object</tt>, <tt>class</tt>, <tt>metaclass</tt> and <tt>baseclass</tt> can
be further specialized with the parameter option <tt>type</tt> to restrict
the permissible values to instances of certain classes. We can use for
example the native value constraint <tt>object</tt> either for testing
whether an argument is some object (without further constraints, as in
<a href="#xmp-default-value">Listing 36</a>, method <tt>foo</tt>), or we can
constrain the value further to some type (direct or indirect instance
of a class). This is shown by method <tt>work</tt> in
<a href="#xmp-check-parameterized">Listing 39</a> which requires
the parameter <tt>-person</tt> to be an instance of class <tt>Person</tt> and the
parameter <tt>-project</tt> to be an instance of class <tt>Project</tt>.</p></div>
</div>
<div class="sect4">
<h5 id="_scripted_value_constraints">Scripted Value Constraints</h5>
<div class="paragraph"><p>The set of predefined value checkers can be extended by application
programs via defining methods following certain conventions. The user
defined value checkers are defined as methods of the class <tt>nx::Slot</tt>
or of one of its subclasses or instances. We will address such cases
in the next sections. In the following example we define two new
value checkers on class <tt>nx::Slot</tt>. The first value checker is called
<tt>groupsize</tt>, the second one is called <tt>choice</tt>.</p></div>
<div class="paragraph" id="xmp-user-types"><div class="title">Listing 40: Scripted Value Checker for Method Parameters</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-comment'>#
</span><span class='nx-comment'># Value checker named "groupsize"
</span><span class='nx-comment'>#
</span>::nx::Slot <span class='nx-keyword'>method</span> type=groupsize {name value} {
  <span class='nx-keyword'>if</span> {<span class='nx-variable'>$value</span> &lt; 1 || <span class='nx-variable'>$value</span> &gt; 6} {
    <span class='nx-keyword'>error</span> <span class='nx-string'>"Value '$value' of parameter $name is not between 1 and 6"</span>
  }
}

<span class='nx-comment'>#
</span><span class='nx-comment'># Value checker named "choice" with extra argument
</span><span class='nx-comment'>#
</span>::nx::Slot <span class='nx-keyword'>method</span> type=choice {name value arg} {
  <span class='nx-keyword'>if</span> {<span class='nx-variable'>$value</span> ni [<span class='nx-keyword'>split</span> <span class='nx-variable'>$arg</span> |]} {
    <span class='nx-keyword'>error</span> <span class='nx-string'>"Value '$value' of parameter $name not in permissible values $arg"</span>
  }
}

<span class='nx-comment'>#
</span><span class='nx-comment'># Create an application class D
</span><span class='nx-comment'># using the new value checkers
</span><span class='nx-comment'>#
</span><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> D {
  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> foo {a:groupsize} {
    <span class='nx-comment'># ...
</span>  }
  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> bar {a:choice,arg=red|yellow|green b:choice,arg=good|bad} {
    <span class='nx-comment'># ...
</span>  }
}

D <span class='nx-keyword'>create</span> d1

<span class='nx-comment'># testing "groupsize"
</span>d1 foo 2
d1 foo 10

<span class='nx-comment'># testing "choice"
</span>d1 bar green good
d1 bar pink bad</pre></td></tr></table></div></div>
<div class="paragraph"><p>In order to define a checker <tt>groupsize</tt> a method of the name
<tt>type=groupsize</tt> is defined. This method receives two arguments,
<tt>name</tt> and <tt>value</tt>. The first argument is the name of the parameter
(mostly used for the error message) and the second parameter is
provided value. The value checker simply tests whether the provided
value is between 1 and 3 and raises an exception if this is not the
case (invocation in line 36 in <a href="#xmp-user-types">Listing 40</a>).</p></div>
<div class="paragraph"><p>The checker <tt>groupsize</tt> has the permissible values defined in its
method&#8217;s body. It is as well possible to define more generic checkers
that can be parameterized. For this parameterization, one can pass an
argument to the checker method (last argument). The checker <tt>choice</tt>
can be used for restricting the values to a set of predefined
constants. This set is defined in the parameter specification. The
parameter <tt>a</tt> of method <tt>bar</tt> in <a href="#xmp-user-types">Listing 40</a>
is restricted to the values <tt>red</tt>, <tt>yellow</tt> or <tt>green</tt>, and the
parameter <tt>b</tt> is restricted to <tt>good</tt> or <tt>bad</tt>. Note that the syntax
of the permissible values is solely defined by the definition of the
value checker in lines 13 to 17. The invocation in line 39 will be ok,
the invocation in line 40 will raise an exception, since <tt>pink</tt> is not
allowed.</p></div>
<div class="paragraph"><p>If the same checks are used in many places in the program,
defining names for the value checker will be the better choice since
it improves maintainability. For seldomly used kind of checks, the
parameterized value checkers might be more convenient.</p></div>
</div>
</div>
<div class="sect3">
<h4 id="_multiplicity">3.7.5. Multiplicity</h4>
<div class="sidebarblock">
<div class="content">
<div class="paragraph"><p><strong>Multiplicity</strong> is used to define whether a parameter should receive
single or multiple values.</p></div>
</div></div>
<div class="paragraph"><p>A multiplicity specification has a lower and an upper bound. A lower
bound of <tt>0</tt> means that the value might be empty. A lower bound of <tt>1</tt>
means that the parameter needs at least one value. The upper bound
might be <tt>1</tt> or <tt>n</tt> (or synonymously <tt>*</tt>). While the upper bound of
<tt>1</tt> states that at most one value has to be passed, the upper bound of
<tt>n</tt> says that multiple values are permitted. Other kinds of
multiplicity are currently not allowed.</p></div>
<div class="paragraph"><p>The multiplicity is written as parameter option in the parameter
specification in the form <em>lower-bound</em>..<em>upper-bound</em>. If no
multiplicity is defined the default multiplicity is <tt>1..1</tt>, which
means: provide exactly one (atomic) value (this was the case in the
previous examples).</p></div>
<div class="paragraph" id="xmp-multiplicity"><div class="title">Listing 41: Method Parameters with Explicit Multiplicity</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Object</span> <span class='nx-keyword'>create</span> o6 {

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Positional parameter with an possibly empty
</span>  <span class='nx-comment'># single value
</span>  <span class='nx-comment'>#
</span>  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> foo {x:integer,0..1} {
    <span class='nx-keyword'>puts</span> <span class='nx-string'>"x=$x"</span>
  }

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Positional parameter with an possibly empty
</span>  <span class='nx-comment'># list of values value
</span>  <span class='nx-comment'>#
</span>  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> bar {x:integer,0..n} {
    <span class='nx-keyword'>puts</span> <span class='nx-string'>"x=$x"</span>
  }

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Positional parameter with a non-empty
</span>  <span class='nx-comment'># list of values
</span>  <span class='nx-comment'>#
</span>  <span class='nx-keyword'>:public</span> <span class='nx-keyword'>method</span> baz {x:integer,1..n} {
    <span class='nx-keyword'>puts</span> <span class='nx-string'>"x=$x"</span>
  }
}</pre></td></tr></table></div></div>
<div class="paragraph"><p><a href="#xmp-multiplicity">Listing 41</a> contains three examples for
positional parameters with different multiplicities. Multiplicity is
often combined with value constraints. A parameter specification of
the form <tt>x:integer,0..n</tt> means that the parameter <tt>x</tt> receives a list
of integers, which might be empty. Note that the value constraints are
applied to every single element of the list.</p></div>
<div class="paragraph"><p>The parameter specification <tt>x:integer,0..1</tt> means that <tt>x</tt> might be
an integer or it might be empty. This is one style of specifying that
no explicit value is passed for a certain parameter. Another style is
to use required or optional parameters. NX does not enforce any
particular style for handling unspecified values.</p></div>
<div class="paragraph"><p>All the examples in <a href="#xmp-multiplicity">Listing 41</a> are for
single positional parameters. Certainly, multiplicity is fully
orthogonal with the other parameter features and can be used as well
for multiple parameters, non-positional parameter, default values,
etc.</p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_advanced_language_features">4. Advanced Language Features</h2>
<div class="sectionbody">
<div class="paragraph"><p>&#8230;</p></div>
<div class="sect2">
<h3 id="_objects_classes_and_meta_classes">4.1. Objects, Classes and Meta-Classes</h3>
<div class="paragraph"><p>&#8230;</p></div>
</div>
<div class="sect2">
<h3 id="_resolution_order_and_next_path">4.2. Resolution Order and Next-Path</h3>
<div class="paragraph"><p>&#8230;</p></div>
</div>
<div class="sect2">
<h3 id="_details_on_method_and_object_parameters">4.3. Details on Method and Object Parameters</h3>
<div class="paragraph"><p>The parameter specifications are used in NX for the following
purposes. They are used for</p></div>
<div class="ulist"><ul>
<li>
<p>
the specification of input arguments of methods and commands, for
</p>
</li>
<li>
<p>
the specification of return values of methods and commands, and for
</p>
</li>
<li>
<p>
the specification for the initialization of objects.
</p>
</li>
</ul></div>
<div class="paragraph"><p>We refer to the first two as method parameters and the last one as
object parameters. The examples in the previous sections all parameter
specification were specifications of method parameters.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph"><p><strong>Method parameters</strong> specify properties about permissible values passed
to methods.</p></div>
</div></div>
<div class="paragraph"><p>The method parameter specify how methods are invoked, how the
actual arguments are passed to local variables of the invoked method
and what kind of checks should be performed on these.</p></div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph"><p><strong>Object parameters</strong> are parameters that specify, with what values
instance variables of objects are initialized and how these objects
could be parameterized.</p></div>
</div></div>
<div class="paragraph"><p>Syntactically, object parameters and method parameters are the same,
although there are certain differences (e.g. some parameter options
are only applicable for objects parameters, the list of object
parameters is computed dynamically from the class structures, object
parameters are often used in combination with special setter methods,
etc.).  Consider the following example, where we define the two
application classes <tt>Person</tt> and <tt>Student</tt> with a few properties.</p></div>
<div class="paragraph" id="xmp-object-parameters"><div class="title">Listing 42: Object Parameters</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-comment'>#
</span><span class='nx-comment'># Define a class Person with properties "name"
</span><span class='nx-comment'># and "birthday"
</span><span class='nx-comment'>#
</span><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Person {
  <span class='nx-keyword'>:property</span> name:required
  <span class='nx-keyword'>:property</span> birthday
}

<span class='nx-comment'>#
</span><span class='nx-comment'># Define a class Student as specialization of Person
</span><span class='nx-comment'># with and additional property
</span><span class='nx-comment'>#
</span><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Student -superclass Person {
  <span class='nx-keyword'>:property</span> matnr:required
  <span class='nx-keyword'>:property</span> {oncampus:boolean true}
}

<span class='nx-comment'>#
</span><span class='nx-comment'># Create instances using object parameters
</span><span class='nx-comment'># for the initialization
</span><span class='nx-comment'>#
</span>Person <span class='nx-keyword'>create</span> p1 -name Bob
Student <span class='nx-keyword'>create</span> s1 -name Susan -matnr 4711

<span class='nx-comment'># Access property value via accessor method
</span><span class='nx-keyword'>puts</span> <span class='nx-string'>"The name of s1 is [s1 name]"</span></pre></td></tr></table></div></div>
<div class="paragraph"><p>The class <tt>Person</tt> has two properties <tt>name</tt> and <tt>birthday</tt>, where the
property <tt>name</tt> is required, the property <tt>birthday</tt> is not. The
class <tt>Student</tt> is a subclass of <tt>Person</tt> with the additional required
property <tt>matnr</tt> and an optional property <tt>oncampus</tt> with the
default value <tt>true</tt> (see <a href="#xmp-object-parameters">Listing 42</a>). The class diagram below visualizes these
definitions.</p></div>
<div class="imageblock" id="img-object-parameters" style="text-align:center;">
<div class="content">
<img src="object-parameter.png" alt="object-parameter.png" />
</div>
<div class="title">Figure 43. System and Application Classes</div>
</div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>In NX, these definitions imply that instances of the class of <tt>Person</tt>
have the properties <tt>name</tt> and <tt>birthday</tt> as <em>non-positional object
parameters</em>.  Furthermore it implies that instances of <tt>Student</tt> will
have the object parameters of <tt>Person</tt> augmented with the object
parameters from <tt>Student</tt> (namely <tt>matnr</tt> and <tt>oncampus</tt>).  Based on
these object parameters, we can create a <tt>Person</tt> named <tt>Bob</tt> and a
<tt>Student</tt> named <tt>Susan</tt> with the matriculation number <tt>4711</tt> (see line
23 and 24 in <a href="#xmp-object-parameters">Listing 42</a>). After the object <tt>s1</tt> is created it has the
instance variables <tt>name</tt>, <tt>matnr</tt> and <tt>oncampus</tt> (the latter is
initialized with the default value).</p></div>
<div class="sect3">
<h4 id="_object_parameters_for_all_nx_objects">4.3.1. Object Parameters for all NX Objects</h4>
<div class="paragraph"><p>The object parameters are not limited to the application defined
properties, also NX provides some predefined definitions. Since
<tt>Person</tt> is a subclass of <tt>nx::Object</tt> also the object parameters of
<tt>nx::Object</tt> are inherited. In the introductory stack example, we used
<tt>-mixin</tt> applied to an object to denote per-object mixins (see
<a href="#xmp-using-class-safety">Listing 8</a>). Since <tt>mixin</tt>
is defined as a parameter on <tt>nx::Object</tt> it can be used as an object
parameter <tt>-mixin</tt> for all objects in NX. To put it in other words,
every object can be configured to have per-object mixins. If we would
remove this definition, this feature would be removed as well.</p></div>
<div class="paragraph"><p>As shown in the introductory examples, every object can be configured
via a scripted initialization block (the optional scripted block
specified at object creation as last argument; see
<a href="#xmp-object-stack">Listing 5</a> or
<a href="#xmp-object-integer-stack">Listing 12</a>). The
scripted block and its meaning are as well defined by the means of
object parameters. However, this object parameter is positional (last
argument) and optional (it can be omitted). The following listing shows
(simplified) the object parameters of <tt>Person p1</tt> and <tt>Student s1</tt>.</p></div>
<div class="paragraph" id="xmp-object-parameter-list"><div class="title">Listing 44: Computed Actual Object Parameter (simplified)</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>Object</span> parameter <span class='nx-keyword'>for</span> Person p1:
   -name:required -birthday ...
   -mixin:mixinreg,<span class='nx-keyword'>alias</span>,1..n -filter:filterreg,<span class='nx-keyword'>alias</span>,1..n _:initcmd,optional

<span class='nx-keyword'>Object</span> parameter <span class='nx-keyword'>for</span> Student s1:
   -matnr:required {-oncampus:boolean true}
   -name:required -birthday ...
   -mixin:mixinreg,<span class='nx-keyword'>alias</span>,1..n -filter:filterreg,<span class='nx-keyword'>alias</span>,1..n _:initcmd,optional</pre></td></tr></table></div></div>
<div class="paragraph"><p>The actual values can be obtained via introspection via <tt>Person info
parameter definition</tt>. The object parameter types <tt>mixinreg</tt> and
<tt>filterreg</tt> are for converting definitions of filters and mixins.  The
object parameter type <tt>initcmd</tt> says that the content of this variable
will be executed in the context of the object being created (before
the constructor <tt>init</tt> is called).  More about the object parameter
types later.</p></div>
</div>
<div class="sect3">
<h4 id="_object_parameters_for_all_nx_classes">4.3.2. Object Parameters for all NX Classes</h4>
<div class="paragraph"><p>Since classes are certain kind of objects, classes are parameterized
in the same way as objects. A typical parameter for a class definition
is the relation of the class to its superclass.In our example, we have
specified, that <tt>Student</tt> has <tt>Person</tt> as superclass via the
non-positional object parameter <tt>-superclass</tt>. If no superclass is
specified for a class, the default superclass is
<tt>nx::Object</tt>. Therefore <tt>nx::Object</tt> is the default value for the
parameter <tt>superclass</tt>.</p></div>
<div class="paragraph"><p>Another frequently used parameter for classes is <tt>-mixin</tt> to denote
per-class mixins (see e.g. the introductory Stack example in
<a href="#xmp-class-safestack">Listing 10</a>), which is defined in
the same way.</p></div>
<div class="paragraph"><p>Since <tt>Student</tt> is an instance of the meta-class <tt>nx::Class</tt> it
inherits the object parameters from <tt>nx::Class</tt> (see class diagram
<a href="#img-object-parameters">Figure 43</a>). Therefore, one can
use e.g. <tt>-superclass</tt> in the definition of classes.</p></div>
<div class="paragraph"><p>Since <tt>nx::Class</tt> is a subclass of <tt>nx::Object</tt>, the meta-class
<tt>nx::Class</tt> inherits the parameter definitions from the most general
class <tt>nx::Object</tt>. Therefore, every class might as well be configured
with a scripted initialization block the same way as objects can be
configured. We used actually this scripted initialization block in
most examples for defining the methods of the class. The following
listing shows (simplified) the parameters applicable for <tt>Class
Student</tt>.</p></div>
<div class="paragraph" id="xmp-class-parameter-list"><div class="title">Listing 45: Computed Parameters for a Class (simplified)</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>Object</span> parameter <span class='nx-keyword'>for</span> <span class='nx-keyword'>Class</span> Student:
   -mixin:mixinreg,<span class='nx-keyword'>alias</span>,1..n -filter:filterreg,<span class='nx-keyword'>alias</span>,1..n ...
   {-superclass<span class='nx-keyword'>:class</span>,<span class='nx-keyword'>alias</span>,1..n ::nx::Object} ...</pre></td></tr></table></div></div>
<div class="paragraph"><p>The actual values can be obtained via introspection via <tt>nx::Class info
parameter definition</tt>.</p></div>
</div>
<div class="sect3">
<h4 id="_user_defined_parameter_types">4.3.3. User defined Parameter Types</h4>
<div class="paragraph"><p>More detailed definition of the object parameter types comes here.</p></div>
</div>
<div class="sect3">
<h4 id="_slot_classes_and_slot_objects">4.3.4. Slot Classes and Slot Objects</h4>
<div class="paragraph"><p>In one of the previous sections, we defined scripted (application
defined) checker methods on a class named <tt>nx::Slot</tt>.  In general NX
offers the possibility to define value checkers not only for all
usages of parameters but as well differently for method parameters or
object parameters</p></div>
<div class="imageblock" id="img-slots" style="text-align:center;">
<div class="content">
<img src="slots.png" alt="slots.png" />
</div>
<div class="title">Figure 46. Slot Classes and Objects</div>
</div>
<div class="paragraph"><p></p></div>
</div>
<div class="sect3">
<h4 id="_attribute_slots">4.3.5. Attribute Slots</h4>
<div class="paragraph"><p>Still Missing</p></div>
<div class="ulist"><ul>
<li>
<p>
return value checking
</p>
</li>
<li>
<p>
switch
</p>
</li>
<li>
<p>
initcmd &#8230;
</p>
</li>
<li>
<p>
subst rules
</p>
</li>
<li>
<p>
converter
</p>
</li>
<li>
<p>
incremental slots
</p>
</li>
</ul></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_miscellaneous">5. Miscellaneous</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_profiling">5.1. Profiling</h3>
</div>
<div class="sect2">
<h3 id="_unknown_handlers">5.2. Unknown Handlers</h3>
<div class="paragraph"><p>NX provides two kinds of unknown handlers:</p></div>
<div class="ulist"><ul>
<li>
<p>
Unknown handlers for methods
</p>
</li>
<li>
<p>
Unknown handlers for objects and classes
</p>
</li>
</ul></div>
<div class="sect3">
<h4 id="_unknown_handlers_for_methods">5.2.1. Unknown Handlers for Methods</h4>
<div class="paragraph"><p>Object and classes might be equipped
with a method <tt>unknown</tt> which is called in cases, where an unknown
method is called. The method unknown receives as first argument the
called method followed by the provided arguments</p></div>
<div class="paragraph" id="xmp-unknown-method"><div class="title">Listing 47: Unknown Method Handler</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
</pre></td><td class='nx-body'><pre class='nx'>::nx::Object <span class='nx-keyword'>create</span> o {
  <span class='nx-keyword'>:method</span> <span class='nx-keyword'>unknown</span> {called_method args} {
    <span class='nx-keyword'>puts</span> <span class='nx-string'>"Unknown method '$called_method' called"</span>
  }
}

<span class='nx-comment'># Invoke an unknown method for object o:
</span>o foo 1 2 3

<span class='nx-comment'># Output will be: "Unknown method 'foo' called"</span></pre></td></tr></table></div></div>
<div class="paragraph"><p>Without any provision of an unknown method handler, an error will be
raised, when an unknown method is called.</p></div>
</div>
<div class="sect3">
<h4 id="_unknown_handlers_for_objects_and_classes">5.2.2. Unknown Handlers for Objects and Classes</h4>
<div class="paragraph"><p>The next scripting framework provides in addition to unknown method
handlers also a means to dynamically create objects and classes, when
these are referenced. This happens e.g. when superclasses, mixins, or
parent objects are referenced. This mechanism can be used to implement
e.g. lazy loading of these classes.  Nsf allows to register multiple
unknown handlers, each identified by a key (a unique name, different
from the keys of other unknown handlers).</p></div>
<div class="paragraph" id="xmp-unknown-class"><div class="title">Listing 48: Unknown Class Handler</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
</pre></td><td class='nx-body'><pre class='nx'>::nx::Class <span class='nx-keyword'>public</span> <span class='nx-keyword'>class</span> <span class='nx-keyword'>method</span> __unknown {name} {
  <span class='nx-comment'># A very simple unknown handler, showing just how
</span>  <span class='nx-comment'># the mechanism works.
</span>  <span class='nx-keyword'>puts</span> <span class='nx-string'>"***** __unknown called with &lt;$name&gt;"</span>
  ::nx::Class <span class='nx-keyword'>create</span> <span class='nx-variable'>$name</span>
}

<span class='nx-comment'># Register an unknown handler as a method of ::nx::Class
</span>::nsf::object::unknown::add nx {::nx::Class __unknown}

::nx::Object <span class='nx-keyword'>create</span> o {
  <span class='nx-comment'># The class M is unknown at this point
</span>
  <span class='nx-keyword'>:mixin</span> add M
  <span class='nx-comment'># The line above has triggered the unknown class handler,
</span>  <span class='nx-comment'># class M is now defined
</span>
  <span class='nx-keyword'>puts</span> [<span class='nx-keyword'>:info</span> <span class='nx-keyword'>mixin</span> classes]
  <span class='nx-comment'># The output will be:
</span>  <span class='nx-comment'>#     ***** __unknown called with &lt;::M&gt;
</span>  <span class='nx-comment'>#     ::M
</span>}</pre></td></tr></table></div></div>
<div class="paragraph"><p>The Next Scripting Framework allows to add, query, delete and list unknown handlers.</p></div>
<div class="paragraph" id="xmp-unknown-registration"><div class="title">Listing 49: Unknown Handler registration</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-comment'># Interface for unknown handlers:
</span><span class='nx-comment'># nsf::object::unknown::add /key/ /handler/
</span><span class='nx-comment'># nsf::object::unknown::get /key/
</span><span class='nx-comment'># nsf::object::unknown::delete /key/
</span><span class='nx-comment'># nsf::object::unknown::keys</span></pre></td></tr></table></div></div>
<div class="ulist bibliography"><div class="title">References</div><ul>
<li>
<p>
<a id="Zdun"></a> U. Zdun, M. Strembeck, G. Neumann:
  Object-Based and Class-Based Composition of Transitive Mixins,
  Information and Software Technology, 49(8) 2007 .
</p>
</li>
<li>
<p>
<a id="Neumann and Zdun 1999a"></a> G. Neumann and U. Zdun: Filters as a
   language support for design patterns in object-oriented scripting
   languages. In Proceedings of COOTS&#8217;99, 5th Conference on
   Object-Oriented Technologies and Systems, San Diego, May 1999.
</p>
</li>
<li>
<p>
<a id="Neumann and Zdun 1999b"></a> G. Neumann and U. Zdun: Implementing
   object-specific design patterns using per-object mixins. In Proc. of
   NOSA`99, Second Nordic Workshop on Software Architecture, Ronneby,
   Sweden, August 1999.
</p>
</li>
<li>
<p>
<a id="Neumann and Zdun 1999c"></a> G. Neumann and U. Zdun: Enhancing
   object-based system composition through per-object mixins. In
   Proceedings of Asia-Pacific Software Engineering Conference (APSEC),
   Takamatsu, Japan, December 1999.
</p>
</li>
<li>
<p>
<a id="Neumann and Zdun 2000a"></a> G. Neumann and U. Zdun: XOTCL, an
   object-oriented scripting language. In Proceedings of Tcl2k: The
   7th USENIX Tcl/Tk Conference, Austin, Texas, February 2000.
</p>
</li>
<li>
<p>
<a id="Neumann and Zdun 2000b"></a> G. Neumann and U. Zdun: Towards the Usage
   of Dynamic Object Aggregations as a Form of Composition In:
   Proceedings of Symposium of Applied Computing (SAC&#8217;00), Como,
   Italy, Mar 19-21, 2000.
</p>
</li>
<li>
<p>
<a id="Neumann and Sobernig 2009"></a> G. Neumann, S. Sobernig: XOTcl 2.0 - A
   Ten-Year Retrospective and Outlook, in: Proceedings of the Sixteenth
   Annual Tcl/Tk Conference, Portland, Oregon, October, 2009.
</p>
</li>
<li>
<p>
<a id="Ousterhout 1990"></a> J. K. Ousterhout: Tcl: An embeddable command
   language. In Proc. of the 1990 Winter USENIX Conference, January 1990.
</p>
</li>
<li>
<p>
<a id="Ousterhout 1998"></a> J. K. Ousterhout: Scripting: Higher Level
   Programming for the 21st Century, IEEE Computer 31(3), March 1998.
</p>
</li>
<li>
<p>
<a id="Wetherall and Lindblad 1995"></a> D. Wetherall and C. J. Lindblad: Extending Tcl for
   Dynamic Object-Oriented Programming. Proc. of the Tcl/Tk Workshop '95,
   July 1995.
</p>
</li>
</ul></div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Version 2.1<br />
Last updated 2011-12-22 11:52:31 CET
</div>
</div>
</body>
</html>
