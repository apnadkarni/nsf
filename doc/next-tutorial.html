<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.5" />
<title>Tutorial for the Next Scripting Language</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #777777;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }


/*
 * xhtml11 specific
 *
 * */

tt {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

.monospaced {
  font-family: monospace;
  font-size: inherit;
  color: navy;
}

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([2-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName == 'DIV'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName == 'DIV' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(4);
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>Tutorial for the Next Scripting Language</h1>
<span id="author">Gustaf Neumann &lt;neumann@wu-wien.ac.at&gt;, Stefan Sobernig &lt;stefan.sobernig@wu.ac.at&gt;</span><br />
<span id="revnumber">version 2.1,</span>
<span id="revdate">March 2011</span>
<br /><span id="revremark">Written for the Initial Release of the Next Scripting Framework.</span>
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="sidebarblock">
<div class="content">
<div class="title">Abstract</div>
<div class="paragraph"><p>This document provides a tutorial for the Next Scripting
Language NX.</p></div>
</div></div>
<div class="paragraph"><p>The Next Scripting Language (NX) is a highly flexible, Tcl
<a href="#Ousterhout 1990">[Ousterhout 1990]</a> based object oriented scripting language. It is a
successor of XOTcl 1 <a href="#Neumann and Zdun 2000a">[Neumann and Zdun 2000a]</a> and is based on 10
years of experience with XOTcl in projects containing several hundert
thousand lines of code. While XOTcl was the first language designed to
provide <em>language support for design patterns</em>, the focus of the Next
Scripting Framework and NX are on combining this with <em>Language
Oriented Programming</em>. In many respects, NX was designed to ease the
learning of the language by novices (by using a more mainstream
terminology, higher orthogonality of the methods, less predefined
methods), to improve maintainability (remove sources of common errors)
and to encourage developer to write better structured programs (to
provide interfaces) especially for large projects, where many
developers are involved.</p></div>
<div class="paragraph"><p>The Next Scripting Language is based on the Next Scripting Framework
which was developed based on the notion of language oriented
programming. The Next Scripting Frameworks provides C-level support
for defining and hosting multiple object systems in a single Tcl
interpreter. The whole definition of NX is fully scripted (e.g.
defined in <tt>nx.tcl</tt>). The Next Scripting Framework is shipped with
three language definitions, containing NX and XOTcl 2. Most of the
existing XOTcl 1 programs can be used without modification in the Next
Scripting Framework by using XOTcl 2. The Next Scripting Framework
requires Tcl 8.5 or newer.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_nx_and_its_roots">1. NX and its Roots</h2>
<div class="sectionbody">
<div class="paragraph"><p>Object oriented extensions of Tcl have quite a
long history. Two of the most prominent early Tcl based OO languages
were <em>incr Tcl</em> (abbreviated as itcl) and Object Tcl (<em>OTcl</em>
<a href="#Wetherall and Lindblad 1995">[Wetherall and Lindblad 1995]</a>). While itcl provides a traditional
C++/Java-like object system, OTcl was following the CLOS approach and
supports a dynamic object system, allowing incremental class and
object extensions and re-classing of objects.</p></div>
<div class="paragraph"><p>Extended Object Tcl (abbreviated as XOTcl <a href="#Neumann and Zdun 2000a">[Neumann and Zdun 2000a]</a>)
is a successor of OTcl and was the first language providing language
support for design patterns. XOTcl extends OTcl by providing namespace
support, adding assertions, dynamic object aggregations, slots and by
introducing per-object and per-class filters and per-object and
per-class mixins.</p></div>
<div class="paragraph"><p>XOTcl was so far released in more than 30 versions. It is described in
its detail in more than 20 papers and serves as a basis for other
object systems like TclOO [Donal ???]. The scripting language <em>NX</em> and
the <em>Next Scripting Framework</em> <a href="#Neumann and Sobernig 2009">[Neumann and Sobernig 2009]</a> extend
the basic ideas of XOTcl by providing support for <em>language-oriented
programming</em>. The the Next Scripting Framework supports multiple
object systems concurrently. Effectively, every object system has
different base classes for creating objects and classes. Therefore,
these object systems can have different different interfaces and can
follow different naming conventions for built-in methods. Currently,
the Next Scripting Framework is packaged with three object systems:
NX, XOTcl 2.0, and TclCool (the language introduced by TIP#279).</p></div>
<div class="imageblock" style="text-align:center;">
<div class="content">
<img src="languages.png" alt="Languages" width="500" />
</div>
<div class="title">Figure 1. Language History of the Next Scripting Language</div>
</div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>The primary purpose of this document is to introduce NX to beginners.
We expect some prior knowledge of programming languages, and some
knowledge about Tcl. In the following sections we introduce NX by
examples. In later sections we introduce the more advanced concepts of
the language. Conceptually, most of the addressed concepts are very
similar in XOTcl. Concerning the differences between NX and XOTcl,
please refer to the "Migration Guide for the Next Scripting Language".</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_introductory_overview_example_stack">2. Introductory Overview Example: Stack</h2>
<div class="sectionbody">
<div class="paragraph"><p>A classical programming example is an implementation of a stack, which
is most likely familiar to many readers from many introductory
programming courses. A stack is a last-in first-out data structure
which is manipulated via operations like <tt>push</tt> (add something to the
stack) and <tt>pop</tt> remove an entry from the stack. These operations are
called <em>methods</em> in the context of object oriented programming
systems. Primary goals of object orientation are encapsulation and
abstraction. Therefore, we define a common unit (a class) that defines
and encapsulates the behavior of a stack and provides methods to a user
of the data structure that abstract from the actual implementation.</p></div>
<div class="sect2">
<h3 id="_define_a_class_stack">2.1. Define a Class "Stack"</h3>
<div class="paragraph"><p>In our first example, we define a class named <tt>Stack</tt> with the methods
<tt>push</tt> and <tt>pop</tt>. When an instance of the stack is created (e.g. a
concrete stack <tt>s1</tt>) the stack will contain an instance variable named
<tt>things</tt> initialized with the an empty list.</p></div>
<div class="paragraph" id="xmp-class-stack"><div class="title">Listing 2: Class Stack</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Stack {

   <span class='nx-comment'>#
</span>   <span class='nx-comment'># Stack of Things
</span>   <span class='nx-comment'>#
</span>
   :<span class='nx-keyword'>variable</span> things {}

   :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> push {thing} {
      <span class='nx-keyword'>set</span> :things [<span class='nx-keyword'>linsert</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 0 <span class='nx-variable'>$thing</span>]
      <span class='nx-keyword'>return</span> <span class='nx-variable'>$thing</span>
   }

   :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> pop {} {
      <span class='nx-keyword'>set</span> top [<span class='nx-keyword'>lindex</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 0]
      <span class='nx-keyword'>set</span> :things [<span class='nx-keyword'>lrange</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 1 end]
      <span class='nx-keyword'>return</span> <span class='nx-variable'>$top</span>
   }
}</pre></td></tr></table></div></div>
<div class="paragraph"><p>Typically, classes are defined in NX via <tt>nx::Class create</tt> followed
by the name of the new class (here: <tt>Stack</tt>). The definition of the
stack placed between curly braces and contains here just the method
definitions. Methods of the class are defined via <tt>:method</tt> followed
by the name of the method, an argument list and the body of the
method, consisting of Tcl and NX statements.</p></div>
<div class="paragraph"><p>When an instance of <tt>Stack</tt> is created, it will contain an instance
variable named <tt>things</tt>. If several <tt>Stack</tt> instances are created,
each of the instances will have their own (same-named but different)
instance variable. The instance variable <tt>things</tt> is used in our
example as a list for the internal representation of the stack. We
define in a next step the methods to access and modify this list
structure. A user of the stack using the the provided methods does not
have to have any knowledge about the name or the structure of the
internal representation (the instance variable <tt>things</tt>).</p></div>
<div class="paragraph"><p>The method <tt>push</tt> receives an argument <tt>thing</tt> which should be placed
on the stack. Note that we do not have to specify the type of the
element on the stack, so we can push strings as well as numbers or
other kind of things. When an element is pushed, we add this element
as the first element to the list <tt>things</tt>. We insert the element using
the Tcl command <tt>linsert</tt> which receives the list as first element,
the position where the element should be added as second and the new
element as third argument. To access the value of the instance
variable we use Tcl&#8217;s the dollar operator followed by the name. The
names of instance variables are preceded with a colon <tt>:</tt>. Since the
name contains a non-plain character, Tcl requires us to put braces
around the name. The command <tt>linsert</tt> and its arguments are placed
between square brackets. This means that the function is called and
returns the new list, where the new element is inserted at the first
position (index 0) in the list <tt>things</tt>. The result of the <tt>linsert</tt>
function is assigned again to the instance variable <tt>things</tt> which is
updated this way.  Finally the method <tt>push</tt> returns the pushed thing
using the <tt>return</tt> statement.</p></div>
<div class="paragraph"><p>The method <tt>pop</tt> returns the most recently stacked element and removes
it from the stack. Therefore, it takes the first element from the list
(using the Tcl command <tt>lindex</tt>), assigns it to the method-scoped
variable <tt>top</tt>, removes the element from the instance variable
<tt>things</tt> (by using the Tcl command <tt>lrange</tt>) and returns the value
popped element <tt>top</tt>.</p></div>
<div class="paragraph"><p>This finishes our first implementation of the the stack, more enhanced
versions will follow. Note that the methods <tt>push</tt> and <tt>pop</tt> are
defined as <tt>public</tt>; this means that these methods can be
used from all other objects in the system. Therefore, these methods
provide an interface to the stack implementation.</p></div>
<div class="paragraph" id="xmp-using-stack"><div class="title">Listing 3: Using the Stack</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-comment'>#!/bin/env tclsh
</span><span class='nx-keyword'>package</span> require nx

<span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Stack {

   <span class='nx-comment'>#
</span>   <span class='nx-comment'># Stack of Things
</span>   <span class='nx-comment'>#
</span>   ....
}

Stack <span class='nx-keyword'>create</span> s1
s1 push a
s1 push b
s1 push c
<span class='nx-keyword'>puts</span> [s1 pop]
<span class='nx-keyword'>puts</span> [s1 pop]
s1 <span class='nx-keyword'>destroy</span></pre></td></tr></table></div></div>
<div class="paragraph"><p>Now we want to use the stack. The code snipped in <a href="#xmp-using-stack">Listing 3</a> shows how to use the class Stack in a script.
Since NX is based on Tcl, the script will be called with the Tcl shell
<tt>tclsh</tt>. In the Tcl shell we have to <tt>require package nx</tt> to use the
Next Scripting Framework and NX. The next lines contain the definition
of the stack as presented before. Of course, it is as well possible to
make the definition of the stack an own package, such we could simple
say <tt>package require stack</tt>, or to save the definition of a stack
simply in a file and load it via <tt>source</tt>.</p></div>
<div class="paragraph"><p>In line 12 we create an instance of the stack, namely the stack object
<tt>s1</tt>. The object <tt>s1</tt> has as an instance of the stack access to the
methods, which can be invoked by the name of the object followed by
the method name. In lines 13-15 we push on the stack the values <tt>a</tt>,
then <tt>b</tt>, and <tt>c</tt>. In line 16 we output the result of the <tt>pop</tt> method
using the Tcl command <tt>puts</tt>. We will see on standard output the
value+c+ (the last stacked item). The output of the line 17 is the
value <tt>b</tt> (the previously stacked item). Finally, in line 18 we
destroy the object. This is not necessary here, but shows the life
cycle of an object. In some respects, <tt>destroy</tt> is the counterpart of
<tt>create</tt> from line 12.</p></div>
<div class="imageblock" id="fig-class-object" style="text-align:center;">
<div class="content">
<img src="object-class-appclass.png" alt="object-class-appclass.png" />
</div>
<div class="title">Figure 4. Class and Object Diagram</div>
</div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p><a href="#fig-class-object">Figure 4</a> shows the actual class and
object structure of the first <tt>Stack</tt> example. Note that the common
root class is <tt>nx::Object</tt> that contains methods for all objects.
Since classes are as well objects in NX, <tt>nx::Class</tt> is a
specialization of <tt>nx::Object</tt>. <tt>nx::Class</tt> provides methods for
creating objects, such as the method <tt>create</tt> which is used to create
objects (and classes as well).</p></div>
</div>
<div class="sect2">
<h3 id="_define_an_object_named_stack">2.2. Define an Object Named "stack"</h3>
<div class="paragraph"><p>The definition of the stack in <a href="#xmp-class-stack">Listing 2</a>
is following the traditional object oriented approach, found in
practically every object oriented programming language: Define a class
with some methods, create instances from this class, and use the
methods defined in the class in the instances of the class.</p></div>
<div class="paragraph"><p>In our next example, we introduce <em>generic objects</em> and <em>object
specific methods</em>. With NX, we can define generic objects, which are
instances of the most generic class <tt>nx::Object</tt> (sometimes called
"common root class"). <tt>nx::Object</tt> is predefined and contains a
minimal set of methods applicable to all NX objects.</p></div>
<div class="paragraph"><p>In our second example, we will define a generic object named <tt>stack</tt>
and provide methods for this object. The methods defined in our first
example were methods provided by a class for objects. Now we defined
object specific methods, which are methods applicable only to the
object for which they are defined.</p></div>
<div class="paragraph" id="xmp-object-stack"><div class="title">Listing 5: Object stack</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Object</span> <span class='nx-keyword'>create</span> stack {

   :<span class='nx-keyword'>variable</span> things {}

   :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> push {thing} {
      <span class='nx-keyword'>set</span> :things [<span class='nx-keyword'>linsert</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 0 <span class='nx-variable'>$thing</span>]
      <span class='nx-keyword'>return</span> <span class='nx-variable'>$thing</span>
   }

   :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> pop {} {
      <span class='nx-keyword'>set</span> top [<span class='nx-keyword'>lindex</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 0]
      <span class='nx-keyword'>set</span> :things [<span class='nx-keyword'>lrange</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 1 end]
      <span class='nx-keyword'>return</span> <span class='nx-variable'>$top</span>
   }
}</pre></td></tr></table></div></div>
<div class="paragraph"><p>The example in <a href="#xmp-object-stack">Listing 5</a> defines the
object <tt>stack</tt> in a very similar way as the class <tt>Stack</tt>. But the
following points are different.</p></div>
<div class="ulist"><ul>
<li>
<p>
First, we use <tt>nx::Object</tt> instead of <tt>nx::Class</tt> to denote
  that we want to create a generic object, not a class.
</p>
</li>
<li>
<p>
As in the example above, we use <tt>:variable</tt> to define the
  instance variable <tt>things</tt> for this object (the object <tt>stack</tt>).
</p>
</li>
</ul></div>
<div class="paragraph"><p>The definition for the methods <tt>push</tt> and <tt>pop</tt> are the same as
before, but this times they are object specify. All methods defined on
an object are object-specific. In order to use the stack, we can use
directly the object <tt>stack</tt> in the same way as we have used the object
<tt>s1</tt> in <a href="#xmp-using-stack">Listing 3</a> (e.g. <tt>stack push a</tt>).
this the object <tt>stack</tt>.</p></div>
<div class="imageblock" id="img-object-stack" style="text-align:center;">
<div class="content">
<img src="object-stack.png" alt="object-stack.png" />
</div>
<div class="title">Figure 6. Object stack</div>
</div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>A reader might wonder when to use a class <tt>Stack</tt> or rather an object
<tt>stack</tt>. A big difference is certainly that one can define easily
multiple instances of a class, while the object is actually a
singleton. The concept of the object <tt>stack</tt> is similar to a module
providing a certain functionality via a common interface without
providing the functionality to create multiple instances. The reuse of
methods provided by the class to objects is as well a difference. If
the methods of the class are updated, all instances of the class well
immediately get the modified behavior. But this does not mean that
there is no reuse for the methods of stack possible. NX allows for
example to copy objects (similar to prototype based languages) or to
reuse methods via e.g. aliases (more about this later).</p></div>
<div class="paragraph"><p>Note that we use capitalized names for classes and lowercase names for
instances. This is not required and a pure convention making it easier
to understand scripts without much analysis.</p></div>
</div>
<div class="sect2">
<h3 id="_implementing_features_using_mixin_classes">2.3. Implementing Features using Mixin Classes</h3>
<div class="paragraph"><p>So far, the definition of the stack methods was pretty minimal.
Suppose, we want to define "safe stacks" that protect e.g. against
stack under-runs (a stack under-run happens, when more <tt>pop</tt> than
<tt>push</tt> operations are issued on a stack). Safety checking can be
implemented mostly independent from the implementation details of the
stack (usage of internal data structures). There are as well different
ways of checking the safety. Therefore we say that safety checking is
orthogonal to the stack core implementation.</p></div>
<div class="paragraph"><p>With NX we can define stack-safety as a separate class using methods
with the same names as the implementations before, and "mix" this
behavior into classes or objects. The implementation of <tt>Safety</tt> in
stack under-runs and to issue error messages, when this happens.</p></div>
<div class="paragraph" id="xmp-class-safety"><div class="title">Listing 7: Class Safety</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Safety {

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Implement stack safety by defining an additional
</span>  <span class='nx-comment'># instance variable named "count" that keeps track of
</span>  <span class='nx-comment'># the number of stacked elements. The methods of
</span>  <span class='nx-comment'># this class have the same names and argument lists
</span>  <span class='nx-comment'># as the methods of Stack; these methods "shadow"
</span>  <span class='nx-comment'># the methods of class Stack.
</span>  <span class='nx-comment'>#
</span>
  :<span class='nx-keyword'>variable</span> count 0

  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> push {thing} {
    <span class='nx-keyword'>incr</span> :count
    <span class='nx-keyword'>next</span>
  }

  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> pop {} {
    <span class='nx-keyword'>if</span> {<span class='nx-variable'>${</span><span class='nx-variable'>:count}</span> == 0} then { <span class='nx-keyword'>error</span> <span class='nx-string'>"Stack empty!"</span> }
    <span class='nx-keyword'>incr</span> :count -1
    <span class='nx-keyword'>next</span>
  }
}</pre></td></tr></table></div></div>
<div class="paragraph"><p>Note that the methods of the class <tt>Safety</tt> all end with <tt>next</tt>.
This command is a primitive command of NX, that will call the
same-named method with the same argument list as the current
invocation.</p></div>
<div class="paragraph"><p>Assume we safe the definition of the class <tt>Stack</tt> in a file named
<tt>Stack.tcl</tt> and the definition of the class <tt>Safety</tt> in a file named
<tt>Safety.tcl</tt> in the current directory. When we load the classes
<tt>Stack</tt> and <tt>Safety</tt> into the same script (see the terminal dialog in
e.g. a certain stack <tt>s2</tt> as a safe stack, while all other stacks
(such as <tt>s1</tt>) might be still "unsafe". This can be achieved via the
option <tt>-mixin</tt> at the object creation time (see line 9 in
option <tt>-mixin</tt> mixes the class <tt>Safety</tt> into the new instance <tt>s2</tt>.</p></div>
<div class="paragraph" id="xmp-using-class-safety"><div class="title">Listing 8: Using the Class Safety</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
</pre></td><td class='nx-body'><pre class='nx'>% <span class='nx-keyword'>package</span> require nx
2.0
% <span class='nx-keyword'>source</span> Stack.tcl
::Stack
% <span class='nx-keyword'>source</span> Safety.tcl
::Safety
% Stack <span class='nx-keyword'>create</span> s1
::s1
% Stack <span class='nx-keyword'>create</span> s2 -<span class='nx-keyword'>mixin</span> Safety
::s2
% s2 push a
a
% s2 pop
a
% s2 pop
Stack empty!

% s1 <span class='nx-keyword'>info</span> precedence
::Stack ::<span class='nx-keyword'>nx::Object</span>

% s2 <span class='nx-keyword'>info</span> precedence
::Safety ::Stack ::<span class='nx-keyword'>nx::Object</span></pre></td></tr></table></div></div>
<div class="paragraph"><p>When the method <tt>push</tt> of <tt>s2</tt> is called, first the method of the
mixin class <tt>Safety</tt> will be invoked that increments the counter and
continues with <tt>next</tt> to call the shadowed method, here the method
<tt>push</tt> of the <tt>Stack</tt> implementation that actually pushes the item.
The same happens, when <tt>s2 pop</tt> is invoked, first the method of
<tt>Safety</tt> is called, then the method of the <tt>Stack</tt>. When the stack is
empty (the value of <tt>count</tt> reaches 0), and <tt>pop</tt> is invoked, the
mixin class <tt>Safety</tt> generates an error message (raises an exception),
and does not invoke the method of the <tt>Stack</tt>.</p></div>
<div class="paragraph"><p>The last two commands in <a href="#xmp-using-class-safety">Listing 8</a> use introspection to query for the objects
<tt>s1</tt> and <tt>s2</tt> the order in which the classes are processed. This order
is called the <tt>precedence order</tt> and is obtained via <tt>info
precedence</tt>. We see that the mixin class <tt>Safety</tt> is only in use for
<tt>s2</tt>, and takes there precedence over <tt>Stack</tt>. The common root class
<tt>nx::Object</tt> is for both <tt>s1</tt> and <tt>s2</tt> the base class.</p></div>
<div class="imageblock" id="img-per-object-mixin" style="text-align:center;">
<div class="content">
<img src="per-object-mixin.png" alt="per-object-mixin.png" />
</div>
<div class="title">Figure 9. Per-object Mixin</div>
</div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>Note that the class <tt>Safety</tt> is only mixed into a single object (here
<tt>s2</tt>), therefore we refer to this case as a <em>per-object mixin</em>.
<a href="#img-per-object-mixin">Figure 9</a> shows the class
diagram, where the class <tt>Safety</tt> is used as a per-object mixin for
<tt>s2</tt>.</p></div>
<div class="paragraph"><p>The class <tt>Safety</tt> can be used as well in other ways, such as e.g. for
defining classes for safe stacks &lt;&lt;xmp-class-safestack,</p></div>
<div class="paragraph" id="xmp-class-safestack"><div class="title">Listing 10: Class SafeStack</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-comment'>#
</span><span class='nx-comment'># Create a safe stack class by using Stack and mixin
</span><span class='nx-comment'># Safety
</span><span class='nx-comment'>#
</span><span class='nx-keyword'>Class</span> <span class='nx-keyword'>create</span> SafeStack -<span class='nx-keyword'>superclass</span> Stack -<span class='nx-keyword'>mixin</span> Safety

SafeStack <span class='nx-keyword'>create</span> s3</pre></td></tr></table></div></div>
<div class="paragraph"><p>The difference to the case with the per-object mixin is that now,
<tt>Safety</tt> is mixed into the definition of <tt>SafeStack</tt>. Therefore, all
instances of the class <tt>SafeStack</tt> (here the instance <tt>s3</tt>) will be
using the safety definitions.
for this definition.</p></div>
<div class="imageblock" id="img-per-class-mixin" style="text-align:center;">
<div class="content">
<img src="per-class-mixin.png" alt="per-class-mixin.png" />
</div>
<div class="title">Figure 11. Per-class Mixin</div>
</div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>Note that we could use <tt>Safety</tt> as well as a per-class mixin on
<tt>Stack</tt>. In this case, all stacks would be safe stacks and we could
not provide a selective feature selection (which might be perfectly
fine).</p></div>
</div>
<div class="sect2">
<h3 id="_define_different_kinds_of_stacks">2.4. Define Different Kinds of Stacks</h3>
<div class="paragraph"><p>The definition of <tt>Stack</tt> is generic and allows all kind of elements
to be stacked. Suppose, we want to use the generic stack definition,
but a certain stack (say, stack <tt>s4</tt>) should be a stack for integers
only. This behavior can be achieved by the same means as introduced
already in <a href="#xmp-object-stack">Listing 5</a>, namely
object-specific methods.</p></div>
<div class="paragraph" id="xmp-object-integer-stack"><div class="title">Listing 12: Object Integer Stack</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
</pre></td><td class='nx-body'><pre class='nx'>Stack <span class='nx-keyword'>create</span> s4 {

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Create a stack with a object-specific method
</span>  <span class='nx-comment'># to check the type of entries
</span>  <span class='nx-comment'>#
</span>
  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> push {thing:integer} {
    <span class='nx-keyword'>next</span>
  }
}</pre></td></tr></table></div></div>
<div class="paragraph"><p>The program snippet in <a href="#xmp-object-integer-stack">Listing 12</a> defines an instance <tt>s4</tt> of the class
<tt>Stack</tt> and provides an object specific method for <tt>push</tt> to implement
an integer stack. The method <tt>pull</tt> is the same for the integer stack
as for all other stacks, so it will be reused as usual from the class
<tt>Stack</tt>. The object-specific method <tt>push</tt> of <tt>s4</tt> has a value
constraint in its argument list (<tt>thing:integer</tt>) that makes sure,
that only integers can be stacked. In case the argument is not an
integer, an exception will be raised. Of course, one could perform the
value constraint checking as well in the body of the method <tt>proc</tt> by
accepting an generic argument and by performing the test for the value
in the body of the method. In the case, the passed value is an
integer, the <tt>push</tt> method of <a href="#xmp-object-integer-stack">Listing 12</a> calls <tt>next</tt>, and therefore calls the
shadowed generic definition of <tt>push</tt> as provided by <tt>Stack</tt>.</p></div>
<div class="paragraph" id="xmp-class-integer-stack"><div class="title">Listing 13: Class IntegerStack</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> IntegerStack -<span class='nx-keyword'>superclass</span> Stack {

  <span class='nx-comment'>#
</span>  <span class='nx-comment'># Create a Stack accepting only integers
</span>  <span class='nx-comment'>#
</span>
  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> push {thing:integer} {
    <span class='nx-keyword'>next</span>
  }
}</pre></td></tr></table></div></div>
<div class="paragraph"><p>An alternative approach is shown in
<a href="#xmp-class-integer-stack">Listing 13</a>, where the class
<tt>IntegerStack</tt> is defined, using again the method definition use for
<tt>s4</tt>, this time on the class level.</p></div>
</div>
<div class="sect2">
<h3 id="_define_class_specific_methods">2.5. Define Class Specific Methods</h3>
<div class="paragraph"><p>In our previous examples we defined methods provided by classes
(applicable for its instances) and object-specific methods (methods
defined on objects, only applicable for these objects). In this
section, we introduce methods defined on classes, which are only
applicable for the class objects. Such methods are sometimes called
class methods or "static methods".</p></div>
<div class="paragraph"><p>In NX classes are objects with certain properties (providing methods
for instances, managing object life-cycles; we will come to this later
in more detail). Since classes are objects, we can define as well
object-specific methods for the class objects. However, since
<tt>:method</tt> applied on classes defines methods for instances, we have to
use the method-modifier <tt>class</tt> to denote methods to be
applied on the class itself. Note that class methods are not
inherited to instances. These methods defined on the class object are
actually exactly same as the object-specific methods in the examples
above.</p></div>
<div class="paragraph" id="xmp-stack2"><div class="title">Listing 14: Class Stack2</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Stack2 {

   :<span class='nx-keyword'>public</span> <span class='nx-keyword'>class</span> <span class='nx-keyword'>method</span> available_stacks {} {
      <span class='nx-keyword'>return</span> [<span class='nx-keyword'>llength</span> [:<span class='nx-keyword'>info</span> instances]]
   }

   :<span class='nx-keyword'>variable</span> things {}

   :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> push {thing} {
      <span class='nx-keyword'>set</span> :things [<span class='nx-keyword'>linsert</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 0 <span class='nx-variable'>$thing</span>]
      <span class='nx-keyword'>return</span> <span class='nx-variable'>$thing</span>
   }

   :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> pop {} {
      <span class='nx-keyword'>set</span> top [<span class='nx-keyword'>lindex</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 0]
      <span class='nx-keyword'>set</span> :things [<span class='nx-keyword'>lrange</span> <span class='nx-variable'>${</span><span class='nx-variable'>:things}</span> 1 end]
      <span class='nx-keyword'>return</span> <span class='nx-variable'>$top</span>
   }
}

Stack <span class='nx-keyword'>create</span> s1
Stack <span class='nx-keyword'>create</span> s2

<span class='nx-keyword'>puts</span> [Stack available_stacks]</pre></td></tr></table></div></div>
<div class="paragraph"><p>The class <tt>Stack2</tt> in <a href="#xmp-stack2">Listing 14</a> consists of the the
earlier definition of the class <tt>Stack</tt> extended by the
class-specific method <tt>available_stacks</tt>, that returns the
current number of instances of the stack. The final command <tt>puts</tt>
(line 26) prints 2 to the console.</p></div>
<div class="imageblock" id="img-stack2" style="text-align:center;">
<div class="content">
<img src="stack2.png" alt="stack2.png" />
</div>
<div class="title">Figure 15. Stack2</div>
</div>
<div class="paragraph"><p></p></div>
<div class="paragraph"><p>The class diagram in <a href="#img-stack2">Figure 15</a> shows the
diagrammatical representation of the class object-specific method
<tt>available_stacks</tt>. We omit here the common root class. Since every
class is a specialization of the common root class <tt>nx::Object</tt>, the
common root class is often omitted from the class diagrams.</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_basic_language_features_of_nx">3. Basic Language Features of NX</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_variables_and_properties">3.1. Variables and Properties</h3>
<div class="paragraph"><p>In general, NX does not need variable declarations. It allows to
create, modify or variables on the fly by using e.g. the Tcl commands
<tt>set</tt> and <tt>unset</tt>. Depending on the variable name (or more precisely,
depending on the prefix consisting of colons <tt>:</tt>), a variable is
either local to a method, or an instance variable, or a global
variable.  The rules are:</p></div>
<div class="ulist"><ul>
<li>
<p>
A variable without any colon prefix refers typically to a
   method scoped variable (the variable is created at the begin of the
   invocation of the method and deleted, when the method ends);
   In the example below, the variable <tt>a</tt> is method scoped.
</p>
</li>
<li>
<p>
A variable with a single colon prefix refers to an instance variable
   (the variable is part of the object, when the object is destroyed,
   the variable is deleted as well. In the example below, the variable
   <tt>b</tt> is an instance variable.
</p>
</li>
<li>
<p>
a variable with two leading colons refers to a global variable (the
  lifespan ends when te variable is explicitly unset or the script
  ends). Also variables in placed in Tcl namespaces are global
  variables. In the example below, the variable <tt>c</tt> is a global
  variable.
</p>
</li>
</ul></div>
<div class="paragraph" id="xmp-var-resolver"><div class="title">Listing 16: Scopes of Variables</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>Class</span> <span class='nx-keyword'>create</span> Foo {

  :<span class='nx-keyword'>method</span> foo args {...}
    <span class='nx-comment'># Method scoped variable a
</span>    <span class='nx-keyword'>set</span> a 1
    <span class='nx-comment'># Instance variable b
</span>    <span class='nx-keyword'>set</span> :b 2
    <span class='nx-comment'># Global variable/namespaced variable c
</span>    <span class='nx-keyword'>set</span> ::c 3
  }
}</pre></td></tr></table></div></div>
<div class="paragraph"><p><a href="#xmp-var-resolver">Listing 16</a> shows a method <tt>foo</tt>
of some class <tt>Foo</tt> referring to differently scoped variables.</p></div>
<div class="sect3">
<h4 id="_properties_instance_variables_with_accessors">3.1.1. Properties: Instance Variables with Accessors</h4>
<div class="paragraph"><p>So, in general, there is no need to define or declare instance
variables in NX. However, in some cases, a definition is useful. For
example, one can define properties on classes, which are inherited to
subclasses, and which are used during object initialization. Consider
the following example:</p></div>
<div class="paragraph" id="xmp-properties"><div class="title">Listing 17: Properties</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-comment'>#
</span><span class='nx-comment'># Define a class Person with properties "name"
</span><span class='nx-comment'># and "birthday"
</span><span class='nx-comment'>#
</span><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Person {
  :<span class='nx-keyword'>property</span> name:required
  :<span class='nx-keyword'>property</span> birthday
}

<span class='nx-comment'>#
</span><span class='nx-comment'># Define a class Student as specialization of Person
</span><span class='nx-comment'># with additional properties
</span><span class='nx-comment'>#
</span><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Student -<span class='nx-keyword'>superclass</span> Person {
  :<span class='nx-keyword'>property</span> matnr:required
  :<span class='nx-keyword'>property</span> {oncampus:boolean true}
}

<span class='nx-comment'>#
</span><span class='nx-comment'># Create instances using object parameters
</span><span class='nx-comment'># for the initialization
</span><span class='nx-comment'>#
</span>Person <span class='nx-keyword'>create</span> p1 -name Bob
Student <span class='nx-keyword'>create</span> s1 -name Susan -matnr 4711

<span class='nx-comment'># Access property value via accessor method
</span><span class='nx-keyword'>puts</span> <span class='nx-string'>"The name of s1 is [s1 name]"</span></pre></td></tr></table></div></div>
<div class="paragraph"><p>We define here a class named <tt>Person</tt> with two properties, namely
 <tt>name</tt> and birthday.</p></div>
<div class="paragraph"><p>We refer with the term <em>property</em> to an instance variable with
accessors, where the property definition might carry as well
value-constraints and a default value.</p></div>
<div class="paragraph"><p>When the class <tt>Person</tt> is defined, NX provides as well automatically
accessors. Accessors are methods named like the variables, which are
used to access (to read and write) the underlying instance
variables. Therefore, in our example, the class <tt>Person</tt> has two
methods implied by the <tt>property</tt> definition, namely the method <tt>name</tt>
and the method <tt>birthday</tt>.</p></div>
<div class="paragraph"><p>The class <tt>Student</tt> is defined as a specialization of <tt>Person</tt> with
two additional properties, namely <tt>matnr</tt> and <tt>oncampus</tt>. The property
<tt>matnr</tt> is required (it has to be provided, when an instance of this
class is created), and the property <tt>oncampus</tt> is boolean, and is per
default set to <tt>true</tt>. Note that the class <tt>Student</tt> inherits the
properties of <tt>Person</tt>, therefore it will have 4 properties in total.</p></div>
<div class="paragraph"><p>The property definitions are also used for providing <tt>object
parameters</tt>. These are non-positional parameters provided during
object creation to supply values to the instance variables. In our
listing, we create an instance of <tt>Person</tt> using the object parameter
<tt>name</tt> and provide the value of <tt>Bob</tt> to the instance variable <tt>name</tt>.
Similarly, we create an instance of <tt>Student</tt> using the two object
parameters <tt>name</tt> and <tt>matnr</tt>. Finally we use the accessor method
<tt>name</tt> to obtain the value of the instance variable <tt>name</tt> of object
<tt>s1</tt>.</p></div>
</div>
<div class="sect3">
<h4 id="_instance_variables_without_accessors">3.1.2. Instance Variables without Accessors</h4>
<div class="paragraph"><p>In some cases one would like to define instance variables without
accessors, e.g. for keeping the internal state of an object.  For this
purpose, one can use the predefined method <tt>variable</tt>, which is in
many respects similar to <tt>property</tt>. One difference is, that
<tt>property</tt> uses the same syntax as for method parameters, and
<tt>variable</tt> receives the default value as a separate argument (similar
to the <tt>variable</tt> command in Tcl. The introductory Stack example in in
<a href="#xmp-class-stack">Listing 2</a> used already the method
<tt>variable</tt>.</p></div>
<div class="paragraph" id="xmp-variable"><div class="title">Listing 18: Declaring Variables</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>Class</span> <span class='nx-keyword'>create</span> Base {
  :<span class='nx-keyword'>variable</span> x 1
  <span class='nx-comment'># ...
</span>}

<span class='nx-keyword'>Class</span> <span class='nx-keyword'>create</span> Derived -<span class='nx-keyword'>superclass</span> Base {
  :<span class='nx-keyword'>variable</span> y 2
  <span class='nx-comment'># ...
</span>}

<span class='nx-comment'># Create instance of the class Derived
</span>Derived <span class='nx-keyword'>create</span> d1

<span class='nx-comment'># Object d1 has instance variables
</span><span class='nx-comment'># x == 1 and y == 2</span></pre></td></tr></table></div></div>
<div class="paragraph"><p>Note that the variable definitions are inherited in the same way as
properties. The example in <a href="#xmp-variable">Listing 18</a> shows a
class <tt>Derived</tt> that inherits from <tt>Base</tt>. When an instance <tt>d1</tt> is
created, it will contain the two instance variables <tt>x</tt> and <tt>y</tt>.</p></div>
<div class="paragraph" id="xmp-constructor"><div class="title">Listing 19: Setting Variables in the Constructor</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>Class</span> <span class='nx-keyword'>create</span> Base2 {
 <span class='nx-comment'># ...
</span> :<span class='nx-keyword'>method</span> <span class='nx-keyword'>init</span> {} {
   <span class='nx-keyword'>set</span> :x 1
   <span class='nx-comment'># ....
</span> }
}

<span class='nx-keyword'>Class</span> <span class='nx-keyword'>create</span> Derived2 -<span class='nx-keyword'>superclass</span> Base2 {
 <span class='nx-comment'># ...
</span> :<span class='nx-keyword'>method</span> <span class='nx-keyword'>init</span> {} {
   <span class='nx-keyword'>set</span> :y 2
   <span class='nx-keyword'>next</span>
   <span class='nx-comment'># ....
</span> }
}

<span class='nx-comment'># Create instance of the class Derived2
</span>Derived2 <span class='nx-keyword'>create</span> d2</pre></td></tr></table></div></div>
<div class="paragraph"><p>In many other object oriented languages, the instance variables are
initialized solely by the constructor, similar to class <tt>Derived2</tt> in
<a href="#xmp-constructor">Listing 19</a> . This approach is certainly as
well possible in NX. Note however, that the approach using
constructors requires an explicit method chaining between the
constructors and is less declarative.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_method_definitions">3.2. Method Definitions</h3>
<div class="paragraph"><p>The basic building blocks of an object oriented program are objects,
classes, which contain named pieces of code, the methods.</p></div>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p><strong>Methods</strong> are subroutines (pieces of code) associated with objects
and/or classes. Every method has a name, it receives arguments and
returns a value.</p></div>
</div></div>
<div class="paragraph"><p>There are as well other program units, which are not associated with
objects or classes. Examples for such units are Tcl procs or Tcl
commands.</p></div>
<div class="paragraph"><p>Methods might have different scopes, defining, on which kind of
objects these methods are applicable. We describe this later in more
detail. For the time being, we deal here with methods defined on
classes, which are applicable for the instance of these classes.</p></div>
<div class="sect3">
<h4 id="_scripted_methods">3.2.1. Scripted Methods</h4>
<div class="paragraph"><p>Since NX is a scripting language, most methods are most likely
scripted methods, where the method body contains Tcl code.</p></div>
<div class="paragraph" id="xmp-fido1"><div class="title">Listing 20: Scripted method</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-comment'># Define a class
</span><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Dog {

  <span class='nx-comment'># Define a scripted method for the class
</span>  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> bark {} {
    <span class='nx-keyword'>puts</span> <span class='nx-string'>"[self] Bark, bark, bark."</span>
  }
}

<span class='nx-comment'># Create an instance of the class
</span>Dog <span class='nx-keyword'>create</span> fido

<span class='nx-comment'># The following line prints "::fido Bark, bark, bark."
</span>fido bark</pre></td></tr></table></div></div>
<div class="paragraph"><p>In the example above we create a class <tt>Dog</tt> with a scripted method
named <tt>bark</tt>. The method body defines the code, which is executed when
the method is invoked. In this example, the method <tt>bar</tt> will print
out a line on the terminal starting with the object name (determined
by the built in command <tt>self</tt> followed by "Bark, bark, bark.".
This method is defined on a class (the class contains the method) and
applicable to instances of the class (here the instance <tt>fido</tt>).</p></div>
</div>
<div class="sect3">
<h4 id="_c_implemented_methods">3.2.2. C-implemented Methods</h4>
<div class="paragraph"><p>Not all of the methods usable in NX are scripted methods. There are
for example predefined methods, that we used already in our examples,
which are implemented in C. For example, in <a href="#xmp-fido1">Listing 20</a>
we used the method <tt>create</tt> to create the class <tt>Dog</tt> and to create
the dog instance <tt>fido</tt>.</p></div>
<div class="paragraph"><p>Also application developer might define their own functions in C, but
this is an advanced topic, not covered here. However, application
developer might reuse some generic C code to define their own
C-implemented methods. Such methods are for example <em>accessors</em>,
<em>forwarders</em> and <em>aliases</em>.</p></div>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>An <strong>accessor</strong> is a (in most cases) C-implemented method to access
instance variables of an object. A call to an accessor with no arguments
uses the accessor as a getter, obtaining the value of the associated
variable. A call to an accessor with an argument uses it as a setter,
setting the value of the associated variable.</p></div>
</div></div>
<div class="paragraph"><p>We used accessors as well already in the section about properties,
which define accessors automatically.</p></div>
<div class="paragraph" id="xmp-fido2"><div class="title">Listing 21: Accessor Methods</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Dog {
 :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> bark {} { <span class='nx-keyword'>puts</span> <span class='nx-string'>"[self] Bark, bark, bark."</span> }
 :<span class='nx-keyword'>method</span> <span class='nx-keyword'>init</span> {} { Tail <span class='nx-keyword'>create</span> [<span class='nx-keyword'>self</span>]::tail}
}

<span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Tail {
  :<span class='nx-keyword'>property</span> {length:double 5}
  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> wag {} {<span class='nx-keyword'>return</span> Joy}
}

<span class='nx-comment'># Create an instance of the class
</span>Dog <span class='nx-keyword'>create</span> fido

<span class='nx-comment'># Use the accessor "length" as a getter, to obtain the value
</span><span class='nx-comment'># of a property. The following call returns the length of the
</span><span class='nx-comment'># tail of fido
</span>fido::tail length

<span class='nx-comment'># Use the accessor "length" as a setter, to alter the value
</span><span class='nx-comment'># of a property. The following call changes the length of
</span><span class='nx-comment'># the tail of fido
</span>fido::tail length 10

<span class='nx-comment'># Proving an invalid values will raise an error
</span>fido::tail length <span class='nx-string'>"Hello"</span></pre></td></tr></table></div></div>
<div class="paragraph"><p><a href="#xmp-fido2">Listing 21</a> shows an extended example, where every doc
has a tail. The object <tt>tail</tt> is created as a subobject of the dog in
the constructor <tt>init</tt>. The subobject can be accessed by providing the
full name of the subobject <tt>fido::tail</tt>. The method <tt>length</tt> is an
C-implemented accessor, that enforces the value constraint (here a
floating point number, since length uses the value constraint <tt>double</tt>).</p></div>
<div class="paragraph" id="xmp-fido3"><div class="title">Listing 22: Forwarder Methods</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Dog {
  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> bark {} { <span class='nx-keyword'>puts</span> <span class='nx-string'>"[self] Bark, bark, bark."</span> }
  :<span class='nx-keyword'>method</span> <span class='nx-keyword'>init</span> {} {
    Tail <span class='nx-keyword'>create</span> [<span class='nx-keyword'>self</span>]::tail
    :<span class='nx-keyword'>public</span> <span class='nx-keyword'>forward</span> wag [<span class='nx-keyword'>self</span>]::tail wag
  }
}

<span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Tail {
  :<span class='nx-keyword'>property</span> {length 5}
  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> wag {} {<span class='nx-keyword'>return</span> Joy}
}

<span class='nx-comment'># Create an instance of the class
</span>Dog <span class='nx-keyword'>create</span> fido

<span class='nx-comment'># The invocation of "fido wag" is delegated to "fido::tail wag".
</span><span class='nx-comment'># Therefore, the following method returns "Joy".
</span>fido wag</pre></td></tr></table></div></div>
<div class="paragraph"><p><a href="#xmp-fido3">Listing 22</a> again extends the example by adding a
forwarder named <tt>wag</tt> to the object (e.g. <tt>fido</tt>) that redirects all
calls of the form <tt>fido wag</tt> with arbitrary arguments to the subobject
<tt>fido::tail</tt>.</p></div>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>A <strong>forwarder</strong> is a
C-implemented method to redirect an invocation for a certain method
to either a method of other object or to some other method of the
same object. Forwarding an invocation of a method to some other
object is a means of delegation.</p></div>
</div></div>
<div class="paragraph"><p>The functionality of the forwarder can be certainly as well be
implemented as a scripted method, but for the most common cases, the
forward implementation is more efficient, and the <tt>forward</tt> method
expresses the intention of the developer.</p></div>
<div class="paragraph"><p>The forwarder have several options to change e.g. the order of the
arguments, to substitute certain patterns in the argument list
etc. This will be described in later sections.</p></div>
</div>
<div class="sect3">
<h4 id="_method_aliases">3.2.3. Method-Aliases</h4>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>A <strong>method alias</strong> is a means to register an existing method, a Tcl proc or
command under as a method with a certain name on a class or object.</p></div>
</div></div>
<div class="paragraph"><p>In some way, the method alias is a restricted form of a forwarder, but
it does not support delegation to different objects and argument
reordering. The advantage of the method alias is it has close to zero
overhead, especially for aliasing c-implemented methods, since the
methods are simple registered under a different name.</p></div>
<div class="paragraph" id="xmp-fido4"><div class="title">Listing 23: Method-Alias</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Dog {
  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> bark {} { <span class='nx-keyword'>puts</span> <span class='nx-string'>"[self] Bark, bark, bark."</span> }

  <span class='nx-comment'># Define a public alias for the method "bark"
</span>  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>alias</span> warn [:<span class='nx-keyword'>info</span> <span class='nx-keyword'>method</span> handle bark]
  <span class='nx-comment'># ...
</span>}

<span class='nx-comment'># Create an instance of the class
</span>Dog <span class='nx-keyword'>create</span> fido

<span class='nx-comment'># The following line prints "::fido Bark, bark, bark."
</span>fido warn</pre></td></tr></table></div></div>
<div class="paragraph"><p><a href="#xmp-fido4">Listing 23</a> extends the last example by defining an
alias for the method "bark". The example just shows the bare
mechanism. In general, method aliases are a very powerful means
for reusing pre-existing functionality. The full object system of NX
and XOTcl2 is built from aliases, where e.g. the same functionality is
available in NX and XOTcl2 under different names. Method aliases are
as well a means for implementing traits in NX.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_method_protection">3.3. Method Protection</h3>
<div class="paragraph"><p>All kinds of methods might have different kind of protections in NX.
The call-protection defines from which calling context methods might
be called. The Next Scripting Framework supports as well redefinition
protection for methods.</p></div>
<div class="paragraph"><p>NX distinguished between <em>public</em>, <em>protected</em> and <em>private</em> methods,
where the default call-protection is "protected".</p></div>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>A <strong>public</strong> method can be
called from every context. A <strong>protected</strong> method can only be invoked
from the same object. A <strong>private</strong> method can be only invoked from
methods defined on the same entity (e.g. defined on the same class)
via <tt>my -local</tt>.</p></div>
</div></div>
<div class="paragraph"><p>All kind of methods protection are applicable for all kind of methods,
either scripted or C-implemented.</p></div>
<div class="paragraph"><p>The distinction between public and protected is an instrument to
define an interface for classes. Public methods are for consumer of
the classes. Public methods define the intended ways of reusing
classes and objects for consumers. Protected methods are intended for
the implementor of the class or subclasses and not for public
usage. The distinction between protected and public reduces the
coupling between consumers and the implementation and offers more
flexibility to the developer.</p></div>
<div class="paragraph" id="xmp-protected-method"><div class="title">Listing 24: Protected Methods</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Foo {

  <span class='nx-comment'># Define a public method
</span>  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> foo {} {
    <span class='nx-comment'># ....
</span>    <span class='nx-keyword'>return</span> [:helper]
  }

  <span class='nx-comment'># Define a protected method
</span>  :<span class='nx-keyword'>method</span> helper {} {
     <span class='nx-keyword'>return</span> 1
  }
}

<span class='nx-comment'># Create an instance of the class:
</span>Foo <span class='nx-keyword'>create</span> f1

<span class='nx-comment'># The invocation of the public method "foo" returns 1
</span>f1 foo

<span class='nx-comment'># The invocation of the protected method "helper" raises an error:
</span>f1 helper</pre></td></tr></table></div></div>
<div class="paragraph"><p>Note that we could have as well used <tt>:protected method helper &#8230;</tt>
in the above example, but we can omit <tt>protected</tt>, since it is the default
method call protection.</p></div>
<div class="paragraph"><p>The method call-protection of <em>private</em> goes one step further and
helps to hide implementation details also for implementors of
subclasses. Private methods are a means for avoiding unanticipated name
clashes. Consider the following example:</p></div>
<div class="paragraph" id="xmp-private-method"><div class="title">Listing 25: Private Methods</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Base {
  :<span class='nx-keyword'>private</span> <span class='nx-keyword'>method</span> helper {a b} { <span class='nx-keyword'>expr</span> {<span class='nx-variable'>$a</span> + <span class='nx-variable'>$b</span>} }
  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> foo {a b} { <span class='nx-keyword'>my</span> -local helper <span class='nx-variable'>$a</span> <span class='nx-variable'>$b</span> }
}

<span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> Sub -<span class='nx-keyword'>superclass</span> Base {
  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> bar {a b} { <span class='nx-keyword'>my</span> -local helper <span class='nx-variable'>$a</span> <span class='nx-variable'>$b</span> }
  :<span class='nx-keyword'>private</span> <span class='nx-keyword'>method</span> helper {a b} { <span class='nx-keyword'>expr</span> {<span class='nx-variable'>$a</span> * <span class='nx-variable'>$b</span>} }
  :<span class='nx-keyword'>create</span> s1
}

s1 foo 3 4     ;<span class='nx-comment'># returns 7
</span>s1 bar 3 4     ;<span class='nx-comment'># returns 12
</span>s1 helper 3 4  ;<span class='nx-comment'># raises error: unable to dispatch method helper</span></pre></td></tr></table></div></div>
<div class="paragraph"><p>The base class implements a public method <tt>foo</tt> using the helper
method named <tt>helper</tt>. Also the derived class implements a public
method <tt>bar</tt>, which is also using a helper method named <tt>helper</tt>. When
we create an instance <tt>s1</tt> from the derived class, we can call the
method <tt>foo</tt> which uses in turn the private method of the base
class. Therefore, <tt>foo</tt> called with the arguments 3 and 4 returns its
sum. If we would not have used <tt>my -local</tt> for invoking the helper,
<tt>s1</tt> would have tried to call the helper of <tt>Sub</tt>, which would be
incorrect. For all other purposes, the private methods are "invisible"
in all situations, e.g. when mixins are used, or within the
<tt>next</tt>-path, etc.</p></div>
<div class="paragraph"><p>By using <tt>my -local</tt> for the invocation it is possible to call just the
local definition of the method. If we would call the method as usual,
the resolution order would be the same as usual, starting with
filters, mixins, per-object methods and the full intrinsic class
hierarchy.</p></div>
</div>
<div class="sect2">
<h3 id="_applicability_of_methods">3.4. Applicability of Methods</h3>
<div class="paragraph"><p>As defined above, a method is a subroutine defined on an object or
class. This object (or class) contains the method. If the object (or
class) is deleted, the contained methods will be deleted as well.</p></div>
<div class="sect3">
<h4 id="_inherited_methods">3.4.1. Inherited Methods</h4>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>Typically, methods are defined on a class and these methods are
applicable to the instances (direct or indirect) of this class. These
methods are <strong>inherited methods</strong>.</p></div>
</div></div>
<div class="paragraph"><p>In the following example method <tt>foo</tt> is an inherited method defined
on class <tt>C</tt>.</p></div>
<div class="paragraph" id="xmp-instance-applicable"><div class="title">Listing 26: Methods applicable for instances</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> C {
  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> foo {} {<span class='nx-keyword'>return</span> 1}
  :<span class='nx-keyword'>create</span> c1
}

<span class='nx-comment'># Method "foo" is defined on class "C"
</span><span class='nx-comment'># and applicable to the instances of "C"
</span>c1 foo</pre></td></tr></table></div></div>
<div class="paragraph"><p>There are many programming languages that allow only this type of methods.
However, NX allows as well to define methods on objects.</p></div>
</div>
<div class="sect3">
<h4 id="_object_methods">3.4.2. Object Methods</h4>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>Methods contained in objects are <strong>per-object methods</strong>, which are only
applicable on the object, on which they are defined.</p></div>
</div></div>
<div class="paragraph"><p>The following example defines a object specific method <tt>bar</tt> on the
instance <tt>c1</tt> of class <tt>C</tt>, and as well the object specific method
<tt>baz</tt> defined on the object <tt>o1</tt>. Note that we can define a per-object
method that shadows (redefines) for this object an inherited method.</p></div>
<div class="paragraph" id="xmp-object-applicable1"><div class="title">Listing 27: Per-object Method</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> C {
  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> foo {} {<span class='nx-keyword'>return</span> 1}
  :<span class='nx-keyword'>create</span> c1 {
     :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> foo {} {<span class='nx-keyword'>return</span> 2}
     :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> bar {} {<span class='nx-keyword'>return</span> 3}
  }
}

<span class='nx-comment'># Method "bar" is on object specific method of "c1"
</span>c1 bar

<span class='nx-comment'># object-specific method "foo" returns 2
</span>c1 foo

<span class='nx-comment'># Method "baz" is on object specific method of "o1"
</span><span class='nx-keyword'>nx::Object</span> <span class='nx-keyword'>create</span> o1 {
  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> baz {} {<span class='nx-keyword'>return</span> 4}
}
o1 baz</pre></td></tr></table></div></div>
</div>
<div class="sect3">
<h4 id="_class_methods">3.4.3. Class Methods</h4>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>A <strong>class method</strong> is a method defined on a class, which is only
applicable to the class itself.</p></div>
</div></div>
<div class="paragraph"><p>In NX, all classes are objects as well. Classes are certainly special
kind of objects, that have the ability to e.g. create instances and to
provide methods to the instances. Classes manage their instances.</p></div>
<div class="paragraph" id="xmp-object-applicable2"><div class="title">Listing 28: Per-object Method</div><p></p></div>
<div class="listingblock">
<div class="content"><style type='text/css'>
.nx             {color: #000000; font-weight: normal; font-style: normal; padding-left: 10px}
table.nx        {border-collapse: collapse; border-spacing: 3px;}
.nx-linenr      {border-right: 1px solid #DDDDDD;padding-right: 5px; color: #2B547D;font-style: italic;}
.nx-string      {color: #779977; font-weight: normal; font-style: italic;}
.nx-comment     {color: #717ab3; font-weight: normal; font-style: italic;}
.nx-keyword     {color: #7f0055; font-weight: normal; font-style: normal;}
.nx-placeholder {color: #AF663F; font-weight: normal; font-style: italic;}
.nx-variable    {color: #AF663F; font-weight: normal; font-style: normal;}
</style>
<table class='nx'><tr><td class='nx-linenr'><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
</pre></td><td class='nx-body'><pre class='nx'><span class='nx-keyword'>nx::Class</span> <span class='nx-keyword'>create</span> C {
  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>class</span> <span class='nx-keyword'>method</span> bar {} {<span class='nx-keyword'>return</span> 2}
  :<span class='nx-keyword'>public</span> <span class='nx-keyword'>method</span> foo {} {<span class='nx-keyword'>return</span> 1}
  :<span class='nx-keyword'>create</span> c1
}

<span class='nx-comment'># Method "bar" is a class method of class "C"
</span>C bar

<span class='nx-comment'># Method "foo" is an inherited method of "C"
</span>c1 foo

<span class='nx-comment'># When trying to invoke the class method on the
</span><span class='nx-comment'># instance, an error will be raised.
</span>c1 bar</pre></td></tr></table></div></div>
<div class="paragraph"><p>In several other object oriented programming languages, class methods
are called "static methods".</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_ensemble_methods">3.5. Ensemble Methods</h3>
<div class="paragraph"><p>&#8230;</p></div>
</div>
<div class="sect2">
<h3 id="_method_resolution">3.6. Method Resolution</h3>
<div class="literalblock">
<div class="content">
<pre><tt>=== Parameters

NX provides a generalized mechanism for passing values to either
methods (we refer to these as _method parameters_) or to objects
(these are called _object parameters_). Both kind of parameters
might have different features, such as:

- Positional and non-positional parameters
- Required and non-required parameters
- Default values for parameters
- Value-checking for parameters
- Multiplicity of parameters

TODO: complete list above and provide a short summary of the section

Before we discuss method and object parameters in more detail, we
describe the parameter features in the subsequent sections based on
method parameters.

==== Positional and Non-Positional Parameters

If the position of a parameter in the list of formal arguments
(e.g. passed to a function) is significant for its meaning, this is a
_positional_ parameter. If the meaning of the parameter is independent
of its postion, this is a _non-positional_ parameter. When we call a
method with positional parameters, the meaning of the parameters (the
association with the argument in the argument list of the method) is
determined by its position. When we call a method with non-positional
parameters, their meaning is determined via a name passed with the
argument during invocation.

[[xmp-posnonpos]]
.Listing {counter:figure-number}: Positional and Non-Positional Method Parameters
{set:xmp-posnonpos:Listing {figure-number}}
[source,tcl,numbers]
--------------------------------------------------
nx::Object create o1 {

  #
  # Method foo has positional parameters:
  #
  :public method foo {x y} {
    puts "x=$x y=$y"
  }

  #
  # Method bar has non-positional parameters:
  #
  :public method bar {-x -y} {
    puts "x=$x y=$y"
  }

  #
  # Method baz has non-positional and
  # positional parameters:
  #
  :public method baz {-x -y a} {
    puts "x? [info exists x] y? [info exists y] a=$a"
  }
}

# invoke foo (positional parameters)
o1 foo 1 2

# invoke bar (non-positional parameters)
o1 bar -y 3 -x 1
o1 bar -x 1 -y 3

# invoke baz (positional and non-positional parameters)
o1 baz -x 1 100
o1 baz 200
o1 baz -- -y
--------------------------------------------------

Consider the example in &lt;&lt;xmp-posnonpos, {xmp-posnonpos}&gt;&gt;. The method
+foo+ has the argument list +x y+. This means that the first argument
is passed in an invocation like +o1 foo 1 2+ to +x+ (here, the value
+1+), and the second argument is passed to +y+ (here the value +2+).
Method +bar+ has in contrary just with non-positional arguments. Here
we pass the names of the parameter together with the values. In the
invocation +o1 bar -y 3 -x 1+ the names of the parameters are prefixed
with a dash ("-"). No matter whether in which order we write the
non-positional parameters in the invocation (see line 30 and 31 in
&lt;&lt;xmp-posnonpos, {xmp-posnonpos}&gt;&gt;) in both cases the variables +x+
and +y+ in the body of the method +bar+ get the same values assigned
(+x+ becomes +1+, +y+ becomes +3+).

It is certainly possible to combine positional and non-positional
arguments. Method +baz+ provides two non-positional parameter (+-y+
and +-y+) and one positional parameter (namely +a+). The invocation in
line 34 passes the value of +1+ to +x+ and the value of +100+ to +a+.
There is no value passed to +y+, therefore value of +y+ will be
undefined in the body of +baz+, +info exists y+ checks for the
existence of the variable +y+ and returns +0+.

The invocation in line 35 passes only a value to the positional
parameter. A more tricky case is in line 36, where we want to pass
+-y+ as a value to the positional parameter +a+. The case is more
tricky since syntactically the argument parser might consider +-y+ as
the name of one of the non-positional parameter. Therefore we use +--+
(double dash) to indicate the end of the block of the non-positional
parameters and therefore the value of +-y+ is passed to +a+.

==== Optional and Required Parameters

Per default positional parameters are required, and non-positional
parameters are optional (they can be left out). By using parameter
options, we can as well define positional parameters, which are
optional, and non-positional parameters, which are required.

[[xmp-optional-req]]
.Listing {counter:figure-number}: Optional and Required Method Parameters
{set:xmp-optional-req:Listing {figure-number}}
[source,tcl,numbers]
--------------------------------------------------
nx::Object create o2 {

  #
  # Method foo has one required and one optional
  # positional parameter:
  #
  :public method foo {x:required y:optional} {
    puts "x=$x y? [info exists y]"
  }

  #
  # Method bar has one required and one optional
  # non-positional parameter:
  #
  :public method bar {-x:required -y:optional} {
    puts "x=$x y? [info exists y]"
  }
}

# invoke foo (one optional positional parameter is missing)
o2 foo 1
--------------------------------------------------

The example in &lt;&lt;xmp-optional-req, {xmp-optional-req}&gt;&gt; defined method +foo+
with one required and one optional positional parameter. For this
purpose we use the parameter options +required+ and +optional+. The
parameter options are separated from the parameter name by a colon. If
there are multiple parameter options, these are separated by commas
(we show this in later examples).

The parameter definition +x:required+ for method +foo+ is equivalent
to +x+ without any parameter options (see e.g. previous example),
since positional parameters are per default required. The invocation
in line 21 of &lt;&lt;xmp-optional-req, {xmp-optional-req}&gt;&gt; will lead to an
undefined variable +y+ in method +foo+, because no value us passed to
the optional parameter. Note that only trailing positional parameters might be
optional. If we would call method +foo+ of &lt;&lt;xmp-posnonpos,
{xmp-posnonpos}&gt;&gt; with only one argument, the system would raise an
exception.

Similarly, we define method +bar+ in &lt;&lt;xmp-optional-req,
{xmp-optional-req}&gt;&gt; with one required and one optional non-positional
parameter. The parameter definition +-y:optional+ is equivalent to
+-y+, since non-positional parameter are per default optional.
However, the non-positional parameter +-x:required+ is required. If we
invoke +bar+ without it, the system will raise an exception.

==== Default Values for Parameters

Optional parameters might have a default value, which will be used,
when not value is provided for this parameter.  Default values can be
specified for positional and non-positional parameters.

[[xmp-default-value]]
.Listing {counter:figure-number}: Method Parameters with Default Values
{set:xmp-default-value:Listing {figure-number}}
[source,tcl,numbers]
--------------------------------------------------
nx::Object create o3 {

  #
  # Positional parameter with default value:
  #
  :public method foo {x:required {y 101}} {
    puts "x=$x y? [info exists y]"
  }

  #
  # Non-positional parameter with default value:
  #
  :public method bar {{-x 10} {-y 20}} {
    puts "x=$x y? [info exists y]"
  }
}

# use default values
o3 foo
o3 bar
--------------------------------------------------

In order to define a default value, the parameter specification must
be of the form of a 2 element list, where the second argument is the
default value. See for an example in
&lt;&lt;xmp-default-value,{xmp-default-value}&gt;&gt;.

==== Value Constraints

NX provides value constraints for all kind of parameters. By
specifying value constraints a developer can restrict the permissible
values for a parameter and document the expected values in the source
code. Value checking in NX is conditional, it can be turned on or off
in general or on a per-usage level (more about this later). The same
mechanisms can be used not only for input value checking, but as well
for return value checking (we will address this point as well later).

===== Built-in Value Constraints

NX comes with a set of built-in value constraints, which can be
extended on the scripting level. The built-in checkers are either the
native checkers provided directly by the Next Scripting Framework (the
most efficient checkers) or the value checkers provided by Tcl through
+string is ...+. The built-in checkers have as well the advantage that
they can be used also at any time during bootstrap of an object
system, at a time, when e.g. no objects or methods are defined. The
same checkers are used as well for all C-implemented primitives of NX
and the Next Scripting Framework.

[[img-value-checkers]]
image::value-checkers.png[align="center",title="General Applicable Value Checkers in NX"]
{set:img-value-checkers:Figure {figure-number}}

&lt;&lt;img-value-checkers, {img-value-checkers}&gt;&gt; shows the built-in
general applicable value checkers available in NX, which can be used
for all method and object parameters. In the next step, we show how to
use these value-checkers for checking permissible values for method
parameters. Then we will show, how to provide more detailed value
constraints.

[[xmp-value-check]]
.Listing {counter:figure-number}: Method Parameters with Value Constraints
{set:xmp-value-check:Listing {figure-number}}
[source,tcl,numbers]
--------------------------------------------------
nx::Object create o4 {

  #
  # Positional parameter with value constraints:
  #
  :public method foo {x:integer o:object,optional} {
    puts "x=$x o? [info exists o]"
  }

  #
  # Non-positional parameter with value constraints:
  #
  :public method bar {{-x:integer 10} {-verbose:boolean false}} {
    puts "x=$x y=$y"
  }
}

# The following invocation raises an exception
o4 foo a
--------------------------------------------------

Value contraints are specified as parameter options in the parameter
specifications. The parameter specification +x:integer+ defines +x+ as
a required positional parmeter which value is constraint to an
integer. The parameter specification +o:object,optional+ shows how to
combine multiple parameter options. The parameter +o+ is an optional
positional parameter, its value must be an object (see
&lt;&lt;xmp-value-check,{xmp-value-check}&gt;&gt;). Value constraints are
specified exactly the same way for non-positional parameters (see
method +bar+ in &lt;&lt;xmp-value-check,{xmp-value-check}&gt;&gt;).

[[xmp-check-parameterized]]
.Listing {counter:figure-number}: Parameterized Value Constraints
{set:xmp-check-parameterized:Listing {figure-number}}
[source,tcl,numbers]
--------------------------------------------------
#
# Create classes for Person and Project
#
Class create Person
Class create Project

nx::Object create o5 {
  #
  # Parameterized value constraints
  #
  :public method work {
     -person:object,type=Person
     -project:object,type=Project
   } {
    # ...
  }
}

#
# Create a Person and a Project instance
#
Person create gustaf
Project create nx

#
# Use method with value constraints
#
o5 work -person gustaf -project nx
--------------------------------------------------

The native checkers +object+, +class+, +metaclass+ and +baseclass+ can
be further specialized with the parameter option +type+ to restrict
the permissible values to instances of certain classes. We can use for
example the native value constraint +object+ either for testing
whether an argument is some object (without further constraints, as in
&lt;&lt;xmp-default-value, {xmp-default-value}&gt;&gt;, method +foo+), or we can
constrain the value further to some type (direct or indirect instance
of a class). This is shown by method +work+ in
&lt;&lt;xmp-check-parameterized, {xmp-check-parameterized}&gt;&gt; which requires
the parameter +-person+ to be an instance of class +Person+ and the
parameter +-project+ to be an instance of class +Project+.

===== Scripted Value Constraints

The set of predefined value checkers can be extended by application
programs via defining methods following certain conventions. The user
defined value checkers are defined as methods of the class +nx::Slot+
or of one of its subclasses or instances. We will address such cases
in the next sections. In the following example we define two new
value checkers on class +nx::Slot+. The first value checker is called
+groupsize+, the second one is called +choice+.

[[xmp-user-types]]
.Listing {counter:figure-number}: Scripted Value Checker for Method Parameters
{set:xmp-user-types:Listing {figure-number}}
[source,tcl,numbers]
--------------------------------------------------
#
# Value checker named "groupsize"
#
::nx::Slot method type=groupsize {name value} {
  if {$value &lt; 1 || $value &gt; 6} {
    error "Value '$value' of parameter $name is not between 1 and 6"
  }
}

#
# Value checker named "choice" with extra argument
#
::nx::Slot method type=choice {name value arg} {
  if {$value ni [split $arg |]} {
    error "Value '$value' of parameter $name not in permissible values $arg"
  }
}

#
# Create an application class D
# using the new value checkers
#
Class create D {
  :public method foo {a:groupsize} {
    # ...
  }
  :public method bar {a:choice,arg=red|yellow|green b:choice,arg=good|bad} {
    # ...
  }
}

D create d1

# testing "groupsize"
d1 foo 2
d1 foo 10

# testing "choice"
d1 bar green good
d1 bar pink bad
--------------------------------------------------

In order to define a checker +groupsize+ a method of the name
+type=groupsize+ is defined. This method receives two arguments,
+name+ and +value+. The first argument is the name of the parameter
(mostly used for the error message) and the second parameter is
provided value. The value checker simply tests whether the provided
value is between 1 and 3 and raises an exception if this is not the
case (invocation in line 36 in &lt;&lt;xmp-user-types, {xmp-user-types}&gt;&gt;).

The checker +groupsize+ has the permissible values defined in its
method's body. It is as well possible to define more generic checkers
that can be parameterized. For this parameterization, one can pass an
argument to the checker method (last argument). The checker +choice+
can be used for restricting the values to a set of predefined
constants. This set is defined in the parameter specification. The
parameter +a+ of method +bar+ in &lt;&lt;xmp-user-types, {xmp-user-types}&gt;&gt;
is restricted to the values +red+, +yellow+ or +green+, and the
parameter +b+ is restricted to +good+ or +bad+. Note that the syntax
of the permissible values is solely defined by the definition of the
value checker in lines 13 to 17. The invocation in line 39 will be ok,
the invocation in line 40 will raise an exception, since +pink+ is not
allowed.

If the same checks are used in many places in the program,
defining names for the value checker will be the better choice since
it improves maintainability. For seldomly used kind of checks, the
parameterized value checkers might be more convenient.

==== Multiplicity

*****************************************************************************
*Multiplicity* is used to define whether a parameter should receive
single or multiple values.
*****************************************************************************

A multiplicity specification has a lower and an upper bound. A lower
bound of +0+ means that the value might be empty. A lower bound of +1+
means that the the parameter needs at least one value. The upper bound
might be +1+ or +n+ (or synonymously +*+). While the upper bound of
+1+ states that at most one value has to be passed, the upper bound of
+n+ says that multiple values are permitted. Other kinds of
multiplicity are currently not allowed.

The multiplicity is written as parameter option in the parameter
specification in the form _lower-bound_.._upper-bound_. If no
multiplicity is defined the default multiplicity is +1..1+, which
means: provide exactly one (atomic) value (this was the case in the
previous examples).

[[xmp-multiplicity]]
.Listing {counter:figure-number}: Method Parameters with Explicit Multiplicity
{set:xmp-multiplicity:Listing {figure-number}}
[source,tcl,numbers]
--------------------------------------------------
nx::Object create o6 {

  #
  # Positional parameter with an possibly empty
  # single value
  #
  :public method foo {x:integer,0..1} {
    puts "x=$x"
  }

  #
  # Positional parameter with an possibly empty
  # list of values value
  #
  :public method bar {x:integer,0..n} {
    puts "x=$x"
  }

  #
  # Positional parameter with a non-empty
  # list of values
  #
  :public method baz {x:integer,1..n} {
    puts "x=$x"
  }
}
--------------------------------------------------

&lt;&lt;xmp-multiplicity, {xmp-multiplicity}&gt;&gt; contains three examples for
positional parameters with different multiplicities. Multiplicity is
often combined with value constraints. A parameter specification of
the form +x:integer,0..n+ means that the parameter +x+ receives a list
of integers, which might be empty. Note that the value constraints are
applied to every single element of the list.

The parameter specification +x:integer,0..1+ means that +x+ might be
an integer or it might be empty. This is one style of specifying that
no explicit value is passed for a certain parameter. Another style is
to use required or optional parameters. NX does not enforce any
particular style for handling unspecified values.

All the examples in &lt;&lt;xmp-multiplicity, {xmp-multiplicity}&gt;&gt; are for
single positional parameters. Certainly, multiplicity is fully
orthogonal with the other parameter features and can be used as well
for multiple parameters, non-positional parameter, default values,
etc.

== Advanced Language Features

...

=== Objects, Classes and Meta-Classes

...

=== Resolution Order and Next-Path

...

=== Details on Method and Object Parameters

The parameter specifications are used in NX for the following
purposes. They are used for

- the specification of input arguments of methods and commands, for
- the specification of return values of methods and commands, and for
- the specification for the initialization of objects.

We refer to the first two as method parameters and the last one as
object parameters. The examples in the previous sections all parameter
specification were specifications of method parameters.

*****************************************************************************
*Method parameters* specify properties about permissible values passed
to methods.
*****************************************************************************

The method parameter specify how methods are invoked, how the
actual arguments are passed to local variables of the invoked method
and what kind of checks should be performed on these.

*****************************************************************************
*Object parameters* are parameters that specify, with what values
instance variables of objects are initialized and how these objects
could be parameterized.
*****************************************************************************

Syntactically, object parameters and method parameters are the same,
although there are certain differences (e.g. some parameter options
are only applicable for objects parameters, the list of object
parameters is computed dynamically from the class structures, object
parameters are often used in combination with special setter methods,
etc.).  Consider the following example, where we define the two
application classes +Person+ and +Student+ with a few properties.

[[xmp-object-parameters]]
.Listing {counter:figure-number}: Object Parameters
{set:xmp-object-parameters:Listing {figure-number}}
[source,tcl,numbers]
--------------------------------------------------
#
# Define a class Person with properties "name"
# and "birthday"
#
nx::Class create Person {
  :property name:required
  :property birthday
}

#
# Define a class Student as specialization of Person
# with and additional property
#
nx::Class create Student -superclass Person {
  :property matnr:required
  :property {oncampus:boolean true}
}

#
# Create instances using object parameters
# for the initialization
#
Person create p1 -name Bob
Student create s1 -name Susan -matnr 4711

# Access property value via accessor method
puts "The name of s1 is [s1 name]"
--------------------------------------------------

The class +Person+ has two properties +name+ and +birthday+, where the
property +name+ is required, the property +birthday+ is not. The
class +Student+ is a subclass of +Person+ with the additional required
property +matnr+ and an optional property +oncampus+ with the
default value +true+ (see &lt;&lt;xmp-object-parameters,
{xmp-object-parameters}&gt;&gt;). The class diagram below visualizes these
definitions.

[[img-object-parameters]]
image::object-parameter.png[align="center",title="System and Application Classes"]
{set:img-object-parameters:Figure {figure-number}}

In NX, these definitions imply that instances of the class of +Person+
have the properties +name+ and +birthday+ as _non-positional object
parameters_.  Furthermore it implies that instances of +Student+ will
have the object parameters of +Person+ augmented with the object
parameters from +Student+ (namely +matnr+ and +oncampus+).  Based on
these object parameters, we can create a +Person+ named +Bob+ and a
+Student+ named +Susan+ with the matriculation number +4711+ (see line
23 and 24 in &lt;&lt;xmp-object-parameters,
{xmp-object-parameters}&gt;&gt;). After the object +s1+ is created it has the
instance variables +name+, +matnr+ and +oncampus+ (the latter is
initialized with the default value).

==== Object Parameters for all NX Objects

The object parameters are not limited to the application defined
properties, also NX provides some predefined definitions. Since
+Person+ is a subclass of +nx::Object+ also the object parameters of
+nx::Object+ are inherited. In the introductory stack example, we used
+-mixin+ applied to an object to denote per-object mixins (see
&lt;&lt;xmp-using-class-safety, {xmp-using-class-safety}&gt;&gt;). Since +mixin+
is defined as a parameter on +nx::Object+ it can be used as an object
parameter +-mixin+ for all objects in NX. To put it in other words,
every object can be configured to have per-object mixins. If we would
remove this definition, this feature would be removed as well.

As shown in the introductory examples, every object can be configured
via a scripted initialization block (the optional scripted block
specified at object creation as last argument; see
&lt;&lt;xmp-object-stack, {xmp-object-stack}&gt;&gt; or
&lt;&lt;xmp-object-integer-stack, {xmp-object-integer-stack}&gt;&gt;). The
scripted block and its meaning are as well defined by the means of
object parameters. However, this object parameter is positional (last
argument) and optional (it can be omitted). The following listing shows
(simplified) the object parameters of +Person p1+ and +Student s1+.

[[xmp-object-parameter-list]]
.Listing {counter:figure-number}: Computed Actual Object Parameter (simplified)
{set:xmp-object-parameter-list:Listing {figure-number}}
[source,tcl,numbers]
--------------------------------------------------
Object parameter for Person p1:
   -name:required -birthday ...
   -mixin:mixinreg,alias,1..n -filter:filterreg,alias,1..n _:initcmd,optional

Object parameter for Student s1:
   -matnr:required {-oncampus:boolean true}
   -name:required -birthday ...
   -mixin:mixinreg,alias,1..n -filter:filterreg,alias,1..n _:initcmd,optional
--------------------------------------------------

The actual values can be optained via introspection via +Person info
parameter definition+. The object parameter types +mixinreg+ and
+filterreg+ are for converting definitions of filters and mixins.  The
object parameter type +initcmd+ says that the content of this variable
will be executed in the context of the object being created (before
the constructor +init+ is called).  More about the object parameter
types later.

==== Object Parameters for all NX Classes

Since classes are certain kind of objects, classes are parameterized
in the same way as objects. A typical parameter for a class definition
is the relation of the class to its superclass.In our example, we have
specified, that +Student+ has +Person+ as superclass via the
non-positional object parameter +-superclass+. If no superclass is
specified for a class, the default superclass is
+nx::Object+. Therefore +nx::Object+ is the default value for the
parameter +superclass+.

Another frequently used parameter for classes is +-mixin+ to denote
per-class mixins (see e.g. the introductory Stack example in
&lt;&lt;xmp-class-safestack,{xmp-class-safestack}&gt;&gt;), which is defined in
the same way.

Since +Student+ is an instance of the meta-class +nx::Class+ it
inherits the object parameters from +nx::Class+ (see class diagram
&lt;&lt;img-object-parameters,{img-object-parameters}&gt;&gt;). Therefore, one can
use e.g. +-superclass+ in the definition of classes.

Since +nx::Class+ is a subclass of +nx::Object+, the meta-class
+nx::Class+ inherits the parameter definitions from the most general
class +nx::Object+. Therefore, every class might as well be configured
with a scripted initialization block the same way as objects can be
configured. We used actually this scripted initialization block in
most examples for defining the methods of the class. The following
listing shows (simplified) the parameters applicable for +Class
Student+.

[[xmp-class-parameter-list]]
.Listing {counter:figure-number}: Computed Parameters for a Class (simplified)
{set:xmp-class-parameter-list:Listing {figure-number}}
[source,tcl,numbers]
--------------------------------------------------
Object parameter for Class Student:
   -mixin:mixinreg,alias,1..n -filter:filterreg,alias,1..n ...
   {-superclass:class,alias,1..n ::nx::Object} ...
--------------------------------------------------

The actual values can be obtained via introspection via +nx::Class info
parameter definition+.


==== User defined Parameter Types

More detailed definition of the object parameter types comes here.

==== Slot Classes and Slot Objects

In one of the previous sections, we defined scripted (application
defined) checker methods on a class named +nx::Slot+.  In general NX
offers the possibility to define value checkers not only for all
usages of parameters but as well differently for method parameters or
object parameters

[[img-slots]]
image::slots.png[align="center",title="Slot Classes and Objects"]
{set:img-slots:Figure {figure-number}}


==== Attribute Slots


Still Missing

- return value checking
- switch
- initcmd ...
- subst rules
- converter
- incremental slots

== Miscellaneous

=== Profiling

=== Unknown Handlers

NX provides two kinds of unknown handlers:

- Unknown handlers for methods
- Unknown handlers for objects and classes

==== Unknown Handlers for Methods

Object and classes might be equipped
with a method +unknown+ which is called in cases, where an unknown
method is called. The method unknown receives as first argument the
called method followed by the provided arguments

[[xmp-unknown-method]]
.Listing {counter:figure-number}: Unknown Method Handler
{set:xmp-unknown-method:Listing {figure-number}}
[source,tcl,numbers]
--------------------------------------------------
::nx::Object create o {
  :method unknown {called_method args} {
    puts "Unknown method '$called_method' called"
  }
}

# Invoke an unknown method for object o:
o foo 1 2 3

# Output will be: "Unknown method 'foo' called"
--------------------------------------------------

Without any provision of an unknown method handler, an error will be
raised, when an unknown method is called.

==== Unknown Handlers for Objects and Classes

The next scripting framework provides in addition to unknown method
handlers also a means to dynamically create objects and classes, when
these are referenced. This happens e.g. when superclasses, mixins, or
parent objects are referenced. This mechanism can be used to implement
e.g. lazy loading of these classes.  Nsf allows to register multiple
unknown handlers, each identified by a key (a unique name, different
from the keys of other unknown handlers).

[[xmp-unknown-class]]
.Listing {counter:figure-number}: Unknown Class Handler
{set:xmp-unknown-class:Listing {figure-number}}
[source,tcl,numbers]
--------------------------------------------------
::nx::Class public class method __unknown {name} {
  # A very simple unknown handler, showing just how
  # the mechanism works.
  puts "***** __unknown called with &lt;$name&gt;"
  ::nx::Class create $name
}

# Register an unknown handler as a method of ::nx::Class
::nsf::object::unknown::add nx {::nx::Class __unknown}

::nx::Object create o {
  # The class M is unknown at this point

  :mixin add M
  # The line above has triggered the unknown class handler,
  # class M is now defined

  puts [:info mixin classes]
  # The output will be:
  #     ***** __unknown called with &lt;::M&gt;
  #     ::M
}
--------------------------------------------------

The Next Scripting Framework allows to add, query, delete and list unknown handlers.

[[xmp-unknown-registgration]]
.Listing {counter:figure-number}: Unknown Handler registration
{set:xmp-unknown-registgration:Listing {figure-number}}
[source,tcl,numbers]
--------------------------------------------------
# Interface for unknown handlers:
# nsf::object::unknown::add /key/ /handler/
# nsf::object::unknown::get /key/
# nsf::object::unknown::delete /key/
# nsf::object::unknown::keys
--------------------------------------------------


[bibliography]
.References

- [[Zdun, Strembeck, Neumann 2007]] U. Zdun, M. Strembeck, G. Neumann:
  Object-Based and Class-Based Composition of Transitive Mixins,
  Information and Software Technology, 49(8) 2007 .

- [[Neumann and Zdun 1999a]] G. Neumann and U. Zdun: Filters as a
   language support for design patterns in object-oriented scripting
   languages. In Proceedings of COOTS'99, 5th Conference on
   Object-Oriented Technologies and Systems, San Diego, May 1999.

- [[Neumann and Zdun 1999b]] G. Neumann and U. Zdun: Implementing
   object-specific design patterns using per-object mixins. In Proc. of
   NOSA`99, Second Nordic Workshop on Software Architecture, Ronneby,
   Sweden, August 1999.

- [[Neumann and Zdun 1999c]] G. Neumann and U. Zdun: Enhancing
   object-based system composition through per-object mixins. In
   Proceedings of Asia-Pacific Software Engineering Conference (APSEC),
   Takamatsu, Japan, December 1999.

- [[Neumann and Zdun 2000a]] G. Neumann and U. Zdun: XOTCL, an
   object-oriented scripting language. In Proceedings of Tcl2k: The
   7th USENIX Tcl/Tk Conference, Austin, Texas, February 2000.

- [[Neumann and Zdun 2000b]] G. Neumann and U. Zdun: Towards the Usage
   of Dynamic Object Aggregations as a Form of Composition In:
   Proceedings of Symposium of Applied Computing (SAC'00), Como,
   Italy, Mar 19-21, 2000.

- [[Neumann and Sobernig 2009]] G. Neumann, S. Sobernig: XOTcl 2.0 - A
   Ten-Year Retrospective and Outlook, in: Proceedings of the Sixteenth
   Annual Tcl/Tk Conference, Portland, Oregon, October, 2009.

- [[Ousterhout 1990]] J. K. Ousterhout: Tcl: An embeddable command
   language. In Proc. of the 1990 Winter USENIX Conference, January 1990.

- [[Ousterhout 1998]] J. K. Ousterhout: Scripting: Higher Level
   Programming for the 21st Century, IEEE Computer 31(3), March 1998.

- [[Wetherall and Lindblad 1995]] D. Wetherall and C. J. Lindblad: Extending Tcl for
   Dynamic Object-Oriented Programming. Proc. of the Tcl/Tk Workshop '95,
   July 1995.</tt></pre>
</div></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Version 2.1<br />
Last updated 2011-09-12 15:46:18 CEST
</div>
</div>
</body>
</html>
